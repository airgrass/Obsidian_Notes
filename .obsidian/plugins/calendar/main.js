/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/rrule/dist/es5/rrule.js
var require_rrule = __commonJS({
  "node_modules/rrule/dist/es5/rrule.js"(exports, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["rrule"] = factory();
      else
        root["rrule"] = factory();
    })(typeof self !== "undefined" ? self : exports, () => {
      return (
        /******/
        (() => {
          "use strict";
          var __webpack_require__ = {};
          (() => {
            __webpack_require__.d = (exports2, definition) => {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          })();
          (() => {
            __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
          })();
          (() => {
            __webpack_require__.r = (exports2) => {
              if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
              }
              Object.defineProperty(exports2, "__esModule", { value: true });
            };
          })();
          var __webpack_exports__ = {};
          __webpack_require__.r(__webpack_exports__);
          __webpack_require__.d(__webpack_exports__, {
            "ALL_WEEKDAYS": () => (
              /* reexport */
              ALL_WEEKDAYS
            ),
            "Frequency": () => (
              /* reexport */
              Frequency
            ),
            "RRule": () => (
              /* reexport */
              RRule2
            ),
            "RRuleSet": () => (
              /* reexport */
              RRuleSet2
            ),
            "Weekday": () => (
              /* reexport */
              Weekday
            ),
            "datetime": () => (
              /* reexport */
              datetime
            ),
            "rrulestr": () => (
              /* reexport */
              rrulestr
            )
          });
          ;
          var ALL_WEEKDAYS = [
            "MO",
            "TU",
            "WE",
            "TH",
            "FR",
            "SA",
            "SU"
          ];
          var Weekday = (
            /** @class */
            (function() {
              function Weekday2(weekday, n) {
                if (n === 0)
                  throw new Error("Can't create weekday with n == 0");
                this.weekday = weekday;
                this.n = n;
              }
              Weekday2.fromStr = function(str) {
                return new Weekday2(ALL_WEEKDAYS.indexOf(str));
              };
              Weekday2.prototype.nth = function(n) {
                return this.n === n ? this : new Weekday2(this.weekday, n);
              };
              Weekday2.prototype.equals = function(other) {
                return this.weekday === other.weekday && this.n === other.n;
              };
              Weekday2.prototype.toString = function() {
                var s = ALL_WEEKDAYS[this.weekday];
                if (this.n)
                  s = (this.n > 0 ? "+" : "") + String(this.n) + s;
                return s;
              };
              Weekday2.prototype.getJsWeekday = function() {
                return this.weekday === 6 ? 0 : this.weekday + 1;
              };
              return Weekday2;
            })()
          );
          ;
          var isPresent = function(value) {
            return value !== null && value !== void 0;
          };
          var isNumber = function(value) {
            return typeof value === "number";
          };
          var isWeekdayStr = function(value) {
            return typeof value === "string" && ALL_WEEKDAYS.includes(value);
          };
          var isArray = Array.isArray;
          var range = function(start, end) {
            if (end === void 0) {
              end = start;
            }
            if (arguments.length === 1) {
              end = start;
              start = 0;
            }
            var rang = [];
            for (var i = start; i < end; i++)
              rang.push(i);
            return rang;
          };
          var clone = function(array) {
            return [].concat(array);
          };
          var repeat = function(value, times) {
            var i = 0;
            var array = [];
            if (isArray(value)) {
              for (; i < times; i++)
                array[i] = [].concat(value);
            } else {
              for (; i < times; i++)
                array[i] = value;
            }
            return array;
          };
          var toArray = function(item) {
            if (isArray(item)) {
              return item;
            }
            return [item];
          };
          function padStart(item, targetLength, padString) {
            if (padString === void 0) {
              padString = " ";
            }
            var str = String(item);
            targetLength = targetLength >> 0;
            if (str.length > targetLength) {
              return String(str);
            }
            targetLength = targetLength - str.length;
            if (targetLength > padString.length) {
              padString += repeat(padString, targetLength / padString.length);
            }
            return padString.slice(0, targetLength) + String(str);
          }
          var split = function(str, sep, num) {
            var splits = str.split(sep);
            return num ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits;
          };
          var pymod = function(a, b) {
            var r = a % b;
            return r * b < 0 ? r + b : r;
          };
          var divmod = function(a, b) {
            return { div: Math.floor(a / b), mod: pymod(a, b) };
          };
          var empty = function(obj) {
            return !isPresent(obj) || obj.length === 0;
          };
          var notEmpty = function(obj) {
            return !empty(obj);
          };
          var includes = function(arr, val) {
            return notEmpty(arr) && arr.indexOf(val) !== -1;
          };
          ;
          var datetime = function(y, m, d, h, i, s) {
            if (h === void 0) {
              h = 0;
            }
            if (i === void 0) {
              i = 0;
            }
            if (s === void 0) {
              s = 0;
            }
            return new Date(Date.UTC(y, m - 1, d, h, i, s));
          };
          var MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          var ONE_DAY = 1e3 * 60 * 60 * 24;
          var MAXYEAR = 9999;
          var ORDINAL_BASE = datetime(1970, 1, 1);
          var PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
          var getYearDay = function(date) {
            var dateNoTime = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
            return Math.ceil((dateNoTime.valueOf() - new Date(date.getUTCFullYear(), 0, 1).valueOf()) / ONE_DAY) + 1;
          };
          var isLeapYear = function(year) {
            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
          };
          var isDate = function(value) {
            return value instanceof Date;
          };
          var isValidDate = function(value) {
            return isDate(value) && !isNaN(value.getTime());
          };
          var tzOffset = function(date) {
            return date.getTimezoneOffset() * 60 * 1e3;
          };
          var daysBetween = function(date1, date2) {
            var date1ms = date1.getTime();
            var date2ms = date2.getTime();
            var differencems = date1ms - date2ms;
            return Math.round(differencems / ONE_DAY);
          };
          var toOrdinal = function(date) {
            return daysBetween(date, ORDINAL_BASE);
          };
          var fromOrdinal = function(ordinal) {
            return new Date(ORDINAL_BASE.getTime() + ordinal * ONE_DAY);
          };
          var getMonthDays = function(date) {
            var month = date.getUTCMonth();
            return month === 1 && isLeapYear(date.getUTCFullYear()) ? 29 : MONTH_DAYS[month];
          };
          var getWeekday = function(date) {
            return PY_WEEKDAYS[date.getUTCDay()];
          };
          var monthRange = function(year, month) {
            var date = datetime(year, month + 1, 1);
            return [getWeekday(date), getMonthDays(date)];
          };
          var combine = function(date, time) {
            time = time || date;
            return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()));
          };
          var dateutil_clone = function(date) {
            var dolly = new Date(date.getTime());
            return dolly;
          };
          var cloneDates = function(dates) {
            var clones = [];
            for (var i = 0; i < dates.length; i++) {
              clones.push(dateutil_clone(dates[i]));
            }
            return clones;
          };
          var sort = function(dates) {
            dates.sort(function(a, b) {
              return a.getTime() - b.getTime();
            });
          };
          var timeToUntilString = function(time, utc) {
            if (utc === void 0) {
              utc = true;
            }
            var date = new Date(time);
            return [
              padStart(date.getUTCFullYear().toString(), 4, "0"),
              padStart(date.getUTCMonth() + 1, 2, "0"),
              padStart(date.getUTCDate(), 2, "0"),
              "T",
              padStart(date.getUTCHours(), 2, "0"),
              padStart(date.getUTCMinutes(), 2, "0"),
              padStart(date.getUTCSeconds(), 2, "0"),
              utc ? "Z" : ""
            ].join("");
          };
          var untilStringToDate = function(until) {
            var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
            var bits = re.exec(until);
            if (!bits)
              throw new Error("Invalid UNTIL value: ".concat(until));
            return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
          };
          var dateTZtoISO8601 = function(date, timeZone) {
            var dateStr = date.toLocaleString("sv-SE", { timeZone });
            return dateStr.replace(" ", "T") + "Z";
          };
          var dateInTimeZone = function(date, timeZone) {
            var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            var dateInLocalTZ = new Date(dateTZtoISO8601(date, localTimeZone));
            var dateInTargetTZ = new Date(dateTZtoISO8601(date, timeZone !== null && timeZone !== void 0 ? timeZone : "UTC"));
            var tzOffset2 = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
            return new Date(date.getTime() - tzOffset2);
          };
          ;
          var IterResult = (
            /** @class */
            (function() {
              function IterResult2(method, args) {
                this.minDate = null;
                this.maxDate = null;
                this._result = [];
                this.total = 0;
                this.method = method;
                this.args = args;
                if (method === "between") {
                  this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
                  this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
                } else if (method === "before") {
                  this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
                } else if (method === "after") {
                  this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
                }
              }
              IterResult2.prototype.accept = function(date) {
                ++this.total;
                var tooEarly = this.minDate && date < this.minDate;
                var tooLate = this.maxDate && date > this.maxDate;
                if (this.method === "between") {
                  if (tooEarly)
                    return true;
                  if (tooLate)
                    return false;
                } else if (this.method === "before") {
                  if (tooLate)
                    return false;
                } else if (this.method === "after") {
                  if (tooEarly)
                    return true;
                  this.add(date);
                  return false;
                }
                return this.add(date);
              };
              IterResult2.prototype.add = function(date) {
                this._result.push(date);
                return true;
              };
              IterResult2.prototype.getValue = function() {
                var res = this._result;
                switch (this.method) {
                  case "all":
                  case "between":
                    return res;
                  case "before":
                  case "after":
                  default:
                    return res.length ? res[res.length - 1] : null;
                }
              };
              IterResult2.prototype.clone = function() {
                return new IterResult2(this.method, this.args);
              };
              return IterResult2;
            })()
          );
          const iterresult = IterResult;
          ;
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          function __extends(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          }
          var __assign = function() {
            __assign = Object.assign || function __assign2(t) {
              for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
              }
              return t;
            };
            return __assign.apply(this, arguments);
          };
          function __rest(s, e) {
            var t = {};
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
            if (s != null && typeof Object.getOwnPropertySymbols === "function")
              for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                  t[p[i]] = s[p[i]];
              }
            return t;
          }
          function __decorate(decorators, target, key, desc) {
            var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
            if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
            else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
          }
          function __param(paramIndex, decorator) {
            return function(target, key) {
              decorator(target, key, paramIndex);
            };
          }
          function __metadata(metadataKey, metadataValue) {
            if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
          }
          function __awaiter(thisArg, _arguments, P, generator) {
            function adopt(value) {
              return value instanceof P ? value : new P(function(resolve) {
                resolve(value);
              });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
              function fulfilled(value) {
                try {
                  step(generator.next(value));
                } catch (e) {
                  reject(e);
                }
              }
              function rejected(value) {
                try {
                  step(generator["throw"](value));
                } catch (e) {
                  reject(e);
                }
              }
              function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
              }
              step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
          }
          function __generator(thisArg, body) {
            var _ = { label: 0, sent: function() {
              if (t[0] & 1) throw t[1];
              return t[1];
            }, trys: [], ops: [] }, f, y, t, g;
            return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
              return this;
            }), g;
            function verb(n) {
              return function(v) {
                return step([n, v]);
              };
            }
            function step(op) {
              if (f) throw new TypeError("Generator is already executing.");
              while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
              if (op[0] & 5) throw op[1];
              return { value: op[0] ? op[1] : void 0, done: true };
            }
          }
          var __createBinding = Object.create ? (function(o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = { enumerable: true, get: function() {
                return m[k];
              } };
            }
            Object.defineProperty(o, k2, desc);
          }) : (function(o, m, k, k2) {
            if (k2 === void 0) k2 = k;
            o[k2] = m[k];
          });
          function __exportStar(m, o) {
            for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
          }
          function __values(o) {
            var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
            if (m) return m.call(o);
            if (o && typeof o.length === "number") return {
              next: function() {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
            throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
          }
          function __read(o, n) {
            var m = typeof Symbol === "function" && o[Symbol.iterator];
            if (!m) return o;
            var i = m.call(o), r, ar = [], e;
            try {
              while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
            } catch (error) {
              e = { error };
            } finally {
              try {
                if (r && !r.done && (m = i["return"])) m.call(i);
              } finally {
                if (e) throw e.error;
              }
            }
            return ar;
          }
          function __spread() {
            for (var ar = [], i = 0; i < arguments.length; i++)
              ar = ar.concat(__read(arguments[i]));
            return ar;
          }
          function __spreadArrays() {
            for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
            for (var r = Array(s), k = 0, i = 0; i < il; i++)
              for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
            return r;
          }
          function __spreadArray(to, from, pack) {
            if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
            return to.concat(ar || Array.prototype.slice.call(from));
          }
          function __await(v) {
            return this instanceof __await ? (this.v = v, this) : new __await(v);
          }
          function __asyncGenerator(thisArg, _arguments, generator) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var g = generator.apply(thisArg, _arguments || []), i, q = [];
            return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
              return this;
            }, i;
            function verb(n) {
              if (g[n]) i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
            }
            function resume(n, v) {
              try {
                step(g[n](v));
              } catch (e) {
                settle(q[0][3], e);
              }
            }
            function step(r) {
              r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
            }
            function fulfill(value) {
              resume("next", value);
            }
            function reject(value) {
              resume("throw", value);
            }
            function settle(f, v) {
              if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
            }
          }
          function __asyncDelegator(o) {
            var i, p;
            return i = {}, verb("next"), verb("throw", function(e) {
              throw e;
            }), verb("return"), i[Symbol.iterator] = function() {
              return this;
            }, i;
            function verb(n, f) {
              i[n] = o[n] ? function(v) {
                return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
              } : f;
            }
          }
          function __asyncValues(o) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var m = o[Symbol.asyncIterator], i;
            return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
              return this;
            }, i);
            function verb(n) {
              i[n] = o[n] && function(v) {
                return new Promise(function(resolve, reject) {
                  v = o[n](v), settle(resolve, reject, v.done, v.value);
                });
              };
            }
            function settle(resolve, reject, d, v) {
              Promise.resolve(v).then(function(v2) {
                resolve({ value: v2, done: d });
              }, reject);
            }
          }
          function __makeTemplateObject(cooked, raw) {
            if (Object.defineProperty) {
              Object.defineProperty(cooked, "raw", { value: raw });
            } else {
              cooked.raw = raw;
            }
            return cooked;
          }
          ;
          var __setModuleDefault = Object.create ? (function(o, v) {
            Object.defineProperty(o, "default", { enumerable: true, value: v });
          }) : function(o, v) {
            o["default"] = v;
          };
          function __importStar(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) {
              for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
          }
          function __importDefault(mod) {
            return mod && mod.__esModule ? mod : { default: mod };
          }
          function __classPrivateFieldGet(receiver, state, kind, f) {
            if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
            if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
          }
          function __classPrivateFieldSet(receiver, state, value, kind, f) {
            if (kind === "m") throw new TypeError("Private method is not writable");
            if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
            if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
          }
          function __classPrivateFieldIn(state, receiver) {
            if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
            return typeof state === "function" ? receiver === state : state.has(receiver);
          }
          ;
          var CallbackIterResult = (
            /** @class */
            (function(_super) {
              __extends(CallbackIterResult2, _super);
              function CallbackIterResult2(method, args, iterator) {
                var _this = _super.call(this, method, args) || this;
                _this.iterator = iterator;
                return _this;
              }
              CallbackIterResult2.prototype.add = function(date) {
                if (this.iterator(date, this._result.length)) {
                  this._result.push(date);
                  return true;
                }
                return false;
              };
              return CallbackIterResult2;
            })(iterresult)
          );
          const callbackiterresult = CallbackIterResult;
          ;
          var ENGLISH = {
            dayNames: [
              "Sunday",
              "Monday",
              "Tuesday",
              "Wednesday",
              "Thursday",
              "Friday",
              "Saturday"
            ],
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            tokens: {
              SKIP: /^[ \r\n\t]+|^\.$/,
              number: /^[1-9][0-9]*/,
              numberAsText: /^(one|two|three)/i,
              every: /^every/i,
              "day(s)": /^days?/i,
              "weekday(s)": /^weekdays?/i,
              "week(s)": /^weeks?/i,
              "hour(s)": /^hours?/i,
              "minute(s)": /^minutes?/i,
              "month(s)": /^months?/i,
              "year(s)": /^years?/i,
              on: /^(on|in)/i,
              at: /^(at)/i,
              the: /^the/i,
              first: /^first/i,
              second: /^second/i,
              third: /^third/i,
              nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
              last: /^last/i,
              for: /^for/i,
              "time(s)": /^times?/i,
              until: /^(un)?til/i,
              monday: /^mo(n(day)?)?/i,
              tuesday: /^tu(e(s(day)?)?)?/i,
              wednesday: /^we(d(n(esday)?)?)?/i,
              thursday: /^th(u(r(sday)?)?)?/i,
              friday: /^fr(i(day)?)?/i,
              saturday: /^sa(t(urday)?)?/i,
              sunday: /^su(n(day)?)?/i,
              january: /^jan(uary)?/i,
              february: /^feb(ruary)?/i,
              march: /^mar(ch)?/i,
              april: /^apr(il)?/i,
              may: /^may/i,
              june: /^june?/i,
              july: /^july?/i,
              august: /^aug(ust)?/i,
              september: /^sep(t(ember)?)?/i,
              october: /^oct(ober)?/i,
              november: /^nov(ember)?/i,
              december: /^dec(ember)?/i,
              comma: /^(,\s*|(and|or)\s*)+/i
            }
          };
          const i18n = ENGLISH;
          ;
          var contains = function(arr, val) {
            return arr.indexOf(val) !== -1;
          };
          var defaultGetText = function(id) {
            return id.toString();
          };
          var defaultDateFormatter = function(year, month, day) {
            return "".concat(month, " ").concat(day, ", ").concat(year);
          };
          var ToText = (
            /** @class */
            (function() {
              function ToText2(rrule, gettext, language, dateFormatter) {
                if (gettext === void 0) {
                  gettext = defaultGetText;
                }
                if (language === void 0) {
                  language = i18n;
                }
                if (dateFormatter === void 0) {
                  dateFormatter = defaultDateFormatter;
                }
                this.text = [];
                this.language = language || i18n;
                this.gettext = gettext;
                this.dateFormatter = dateFormatter;
                this.rrule = rrule;
                this.options = rrule.options;
                this.origOptions = rrule.origOptions;
                if (this.origOptions.bymonthday) {
                  var bymonthday = [].concat(this.options.bymonthday);
                  var bynmonthday = [].concat(this.options.bynmonthday);
                  bymonthday.sort(function(a, b) {
                    return a - b;
                  });
                  bynmonthday.sort(function(a, b) {
                    return b - a;
                  });
                  this.bymonthday = bymonthday.concat(bynmonthday);
                  if (!this.bymonthday.length)
                    this.bymonthday = null;
                }
                if (isPresent(this.origOptions.byweekday)) {
                  var byweekday = !isArray(this.origOptions.byweekday) ? [this.origOptions.byweekday] : this.origOptions.byweekday;
                  var days = String(byweekday);
                  this.byweekday = {
                    allWeeks: byweekday.filter(function(weekday) {
                      return !weekday.n;
                    }),
                    someWeeks: byweekday.filter(function(weekday) {
                      return Boolean(weekday.n);
                    }),
                    isWeekdays: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") === -1 && days.indexOf("SU") === -1,
                    isEveryDay: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") !== -1 && days.indexOf("SU") !== -1
                  };
                  var sortWeekDays = function(a, b) {
                    return a.weekday - b.weekday;
                  };
                  this.byweekday.allWeeks.sort(sortWeekDays);
                  this.byweekday.someWeeks.sort(sortWeekDays);
                  if (!this.byweekday.allWeeks.length)
                    this.byweekday.allWeeks = null;
                  if (!this.byweekday.someWeeks.length)
                    this.byweekday.someWeeks = null;
                } else {
                  this.byweekday = null;
                }
              }
              ToText2.isFullyConvertible = function(rrule) {
                var canConvert = true;
                if (!(rrule.options.freq in ToText2.IMPLEMENTED))
                  return false;
                if (rrule.origOptions.until && rrule.origOptions.count)
                  return false;
                for (var key in rrule.origOptions) {
                  if (contains(["dtstart", "tzid", "wkst", "freq"], key))
                    return true;
                  if (!contains(ToText2.IMPLEMENTED[rrule.options.freq], key))
                    return false;
                }
                return canConvert;
              };
              ToText2.prototype.isFullyConvertible = function() {
                return ToText2.isFullyConvertible(this.rrule);
              };
              ToText2.prototype.toString = function() {
                var gettext = this.gettext;
                if (!(this.options.freq in ToText2.IMPLEMENTED)) {
                  return gettext("RRule error: Unable to fully convert this rrule to text");
                }
                this.text = [gettext("every")];
                this[RRule2.FREQUENCIES[this.options.freq]]();
                if (this.options.until) {
                  this.add(gettext("until"));
                  var until = this.options.until;
                  this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
                } else if (this.options.count) {
                  this.add(gettext("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
                }
                if (!this.isFullyConvertible())
                  this.add(gettext("(~ approximate)"));
                return this.text.join("");
              };
              ToText2.prototype.HOURLY = function() {
                var gettext = this.gettext;
                if (this.options.interval !== 1)
                  this.add(this.options.interval.toString());
                this.add(this.plural(this.options.interval) ? gettext("hours") : gettext("hour"));
              };
              ToText2.prototype.MINUTELY = function() {
                var gettext = this.gettext;
                if (this.options.interval !== 1)
                  this.add(this.options.interval.toString());
                this.add(this.plural(this.options.interval) ? gettext("minutes") : gettext("minute"));
              };
              ToText2.prototype.DAILY = function() {
                var gettext = this.gettext;
                if (this.options.interval !== 1)
                  this.add(this.options.interval.toString());
                if (this.byweekday && this.byweekday.isWeekdays) {
                  this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
                } else {
                  this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
                }
                if (this.origOptions.bymonth) {
                  this.add(gettext("in"));
                  this._bymonth();
                }
                if (this.bymonthday) {
                  this._bymonthday();
                } else if (this.byweekday) {
                  this._byweekday();
                } else if (this.origOptions.byhour) {
                  this._byhour();
                }
              };
              ToText2.prototype.WEEKLY = function() {
                var gettext = this.gettext;
                if (this.options.interval !== 1) {
                  this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
                }
                if (this.byweekday && this.byweekday.isWeekdays) {
                  if (this.options.interval === 1) {
                    this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
                  } else {
                    this.add(gettext("on")).add(gettext("weekdays"));
                  }
                } else if (this.byweekday && this.byweekday.isEveryDay) {
                  this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
                } else {
                  if (this.options.interval === 1)
                    this.add(gettext("week"));
                  if (this.origOptions.bymonth) {
                    this.add(gettext("in"));
                    this._bymonth();
                  }
                  if (this.bymonthday) {
                    this._bymonthday();
                  } else if (this.byweekday) {
                    this._byweekday();
                  }
                  if (this.origOptions.byhour) {
                    this._byhour();
                  }
                }
              };
              ToText2.prototype.MONTHLY = function() {
                var gettext = this.gettext;
                if (this.origOptions.bymonth) {
                  if (this.options.interval !== 1) {
                    this.add(this.options.interval.toString()).add(gettext("months"));
                    if (this.plural(this.options.interval))
                      this.add(gettext("in"));
                  } else {
                  }
                  this._bymonth();
                } else {
                  if (this.options.interval !== 1) {
                    this.add(this.options.interval.toString());
                  }
                  this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
                }
                if (this.bymonthday) {
                  this._bymonthday();
                } else if (this.byweekday && this.byweekday.isWeekdays) {
                  this.add(gettext("on")).add(gettext("weekdays"));
                } else if (this.byweekday) {
                  this._byweekday();
                }
              };
              ToText2.prototype.YEARLY = function() {
                var gettext = this.gettext;
                if (this.origOptions.bymonth) {
                  if (this.options.interval !== 1) {
                    this.add(this.options.interval.toString());
                    this.add(gettext("years"));
                  } else {
                  }
                  this._bymonth();
                } else {
                  if (this.options.interval !== 1) {
                    this.add(this.options.interval.toString());
                  }
                  this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
                }
                if (this.bymonthday) {
                  this._bymonthday();
                } else if (this.byweekday) {
                  this._byweekday();
                }
                if (this.options.byyearday) {
                  this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
                }
                if (this.options.byweekno) {
                  this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, void 0, gettext("and")));
                }
              };
              ToText2.prototype._bymonthday = function() {
                var gettext = this.gettext;
                if (this.byweekday && this.byweekday.allWeeks) {
                  this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
                } else {
                  this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
                }
              };
              ToText2.prototype._byweekday = function() {
                var gettext = this.gettext;
                if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
                  this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
                }
                if (this.byweekday.someWeeks) {
                  if (this.byweekday.allWeeks)
                    this.add(gettext("and"));
                  this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
                }
              };
              ToText2.prototype._byhour = function() {
                var gettext = this.gettext;
                this.add(gettext("at")).add(this.list(this.origOptions.byhour, void 0, gettext("and")));
              };
              ToText2.prototype._bymonth = function() {
                this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
              };
              ToText2.prototype.nth = function(n) {
                n = parseInt(n.toString(), 10);
                var nth;
                var gettext = this.gettext;
                if (n === -1)
                  return gettext("last");
                var npos = Math.abs(n);
                switch (npos) {
                  case 1:
                  case 21:
                  case 31:
                    nth = npos + gettext("st");
                    break;
                  case 2:
                  case 22:
                    nth = npos + gettext("nd");
                    break;
                  case 3:
                  case 23:
                    nth = npos + gettext("rd");
                    break;
                  default:
                    nth = npos + gettext("th");
                }
                return n < 0 ? nth + " " + gettext("last") : nth;
              };
              ToText2.prototype.monthtext = function(m) {
                return this.language.monthNames[m - 1];
              };
              ToText2.prototype.weekdaytext = function(wday) {
                var weekday = isNumber(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
                return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[weekday];
              };
              ToText2.prototype.plural = function(n) {
                return n % 100 !== 1;
              };
              ToText2.prototype.add = function(s) {
                this.text.push(" ");
                this.text.push(s);
                return this;
              };
              ToText2.prototype.list = function(arr, callback, finalDelim, delim) {
                var _this = this;
                if (delim === void 0) {
                  delim = ",";
                }
                if (!isArray(arr)) {
                  arr = [arr];
                }
                var delimJoin = function(array, delimiter, finalDelimiter) {
                  var list = "";
                  for (var i = 0; i < array.length; i++) {
                    if (i !== 0) {
                      if (i === array.length - 1) {
                        list += " " + finalDelimiter + " ";
                      } else {
                        list += delimiter + " ";
                      }
                    }
                    list += array[i];
                  }
                  return list;
                };
                callback = callback || function(o) {
                  return o.toString();
                };
                var realCallback = function(arg) {
                  return callback && callback.call(_this, arg);
                };
                if (finalDelim) {
                  return delimJoin(arr.map(realCallback), delim, finalDelim);
                } else {
                  return arr.map(realCallback).join(delim + " ");
                }
              };
              return ToText2;
            })()
          );
          const totext = ToText;
          ;
          var Parser = (
            /** @class */
            (function() {
              function Parser2(rules) {
                this.done = true;
                this.rules = rules;
              }
              Parser2.prototype.start = function(text) {
                this.text = text;
                this.done = false;
                return this.nextSymbol();
              };
              Parser2.prototype.isDone = function() {
                return this.done && this.symbol === null;
              };
              Parser2.prototype.nextSymbol = function() {
                var best;
                var bestSymbol;
                this.symbol = null;
                this.value = null;
                do {
                  if (this.done)
                    return false;
                  var rule = void 0;
                  best = null;
                  for (var name_1 in this.rules) {
                    rule = this.rules[name_1];
                    var match = rule.exec(this.text);
                    if (match) {
                      if (best === null || match[0].length > best[0].length) {
                        best = match;
                        bestSymbol = name_1;
                      }
                    }
                  }
                  if (best != null) {
                    this.text = this.text.substr(best[0].length);
                    if (this.text === "")
                      this.done = true;
                  }
                  if (best == null) {
                    this.done = true;
                    this.symbol = null;
                    this.value = null;
                    return;
                  }
                } while (bestSymbol === "SKIP");
                this.symbol = bestSymbol;
                this.value = best;
                return true;
              };
              Parser2.prototype.accept = function(name) {
                if (this.symbol === name) {
                  if (this.value) {
                    var v = this.value;
                    this.nextSymbol();
                    return v;
                  }
                  this.nextSymbol();
                  return true;
                }
                return false;
              };
              Parser2.prototype.acceptNumber = function() {
                return this.accept("number");
              };
              Parser2.prototype.expect = function(name) {
                if (this.accept(name))
                  return true;
                throw new Error("expected " + name + " but found " + this.symbol);
              };
              return Parser2;
            })()
          );
          function parseText(text, language) {
            if (language === void 0) {
              language = i18n;
            }
            var options = {};
            var ttr = new Parser(language.tokens);
            if (!ttr.start(text))
              return null;
            S();
            return options;
            function S() {
              ttr.expect("every");
              var n = ttr.acceptNumber();
              if (n)
                options.interval = parseInt(n[0], 10);
              if (ttr.isDone())
                throw new Error("Unexpected end");
              switch (ttr.symbol) {
                case "day(s)":
                  options.freq = RRule2.DAILY;
                  if (ttr.nextSymbol()) {
                    AT();
                    F();
                  }
                  break;
                // FIXME Note: every 2 weekdays != every two weeks on weekdays.
                // DAILY on weekdays is not a valid rule
                case "weekday(s)":
                  options.freq = RRule2.WEEKLY;
                  options.byweekday = [RRule2.MO, RRule2.TU, RRule2.WE, RRule2.TH, RRule2.FR];
                  ttr.nextSymbol();
                  AT();
                  F();
                  break;
                case "week(s)":
                  options.freq = RRule2.WEEKLY;
                  if (ttr.nextSymbol()) {
                    ON();
                    AT();
                    F();
                  }
                  break;
                case "hour(s)":
                  options.freq = RRule2.HOURLY;
                  if (ttr.nextSymbol()) {
                    ON();
                    F();
                  }
                  break;
                case "minute(s)":
                  options.freq = RRule2.MINUTELY;
                  if (ttr.nextSymbol()) {
                    ON();
                    F();
                  }
                  break;
                case "month(s)":
                  options.freq = RRule2.MONTHLY;
                  if (ttr.nextSymbol()) {
                    ON();
                    F();
                  }
                  break;
                case "year(s)":
                  options.freq = RRule2.YEARLY;
                  if (ttr.nextSymbol()) {
                    ON();
                    F();
                  }
                  break;
                case "monday":
                case "tuesday":
                case "wednesday":
                case "thursday":
                case "friday":
                case "saturday":
                case "sunday":
                  options.freq = RRule2.WEEKLY;
                  var key = ttr.symbol.substr(0, 2).toUpperCase();
                  options.byweekday = [RRule2[key]];
                  if (!ttr.nextSymbol())
                    return;
                  while (ttr.accept("comma")) {
                    if (ttr.isDone())
                      throw new Error("Unexpected end");
                    var wkd = decodeWKD();
                    if (!wkd) {
                      throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
                    }
                    options.byweekday.push(RRule2[wkd]);
                    ttr.nextSymbol();
                  }
                  AT();
                  MDAYs();
                  F();
                  break;
                case "january":
                case "february":
                case "march":
                case "april":
                case "may":
                case "june":
                case "july":
                case "august":
                case "september":
                case "october":
                case "november":
                case "december":
                  options.freq = RRule2.YEARLY;
                  options.bymonth = [decodeM()];
                  if (!ttr.nextSymbol())
                    return;
                  while (ttr.accept("comma")) {
                    if (ttr.isDone())
                      throw new Error("Unexpected end");
                    var m = decodeM();
                    if (!m) {
                      throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
                    }
                    options.bymonth.push(m);
                    ttr.nextSymbol();
                  }
                  ON();
                  F();
                  break;
                default:
                  throw new Error("Unknown symbol");
              }
            }
            function ON() {
              var on = ttr.accept("on");
              var the = ttr.accept("the");
              if (!(on || the))
                return;
              do {
                var nth = decodeNTH();
                var wkd = decodeWKD();
                var m = decodeM();
                if (nth) {
                  if (wkd) {
                    ttr.nextSymbol();
                    if (!options.byweekday)
                      options.byweekday = [];
                    options.byweekday.push(RRule2[wkd].nth(nth));
                  } else {
                    if (!options.bymonthday)
                      options.bymonthday = [];
                    options.bymonthday.push(nth);
                    ttr.accept("day(s)");
                  }
                } else if (wkd) {
                  ttr.nextSymbol();
                  if (!options.byweekday)
                    options.byweekday = [];
                  options.byweekday.push(RRule2[wkd]);
                } else if (ttr.symbol === "weekday(s)") {
                  ttr.nextSymbol();
                  if (!options.byweekday) {
                    options.byweekday = [RRule2.MO, RRule2.TU, RRule2.WE, RRule2.TH, RRule2.FR];
                  }
                } else if (ttr.symbol === "week(s)") {
                  ttr.nextSymbol();
                  var n = ttr.acceptNumber();
                  if (!n) {
                    throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
                  }
                  options.byweekno = [parseInt(n[0], 10)];
                  while (ttr.accept("comma")) {
                    n = ttr.acceptNumber();
                    if (!n) {
                      throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
                    }
                    options.byweekno.push(parseInt(n[0], 10));
                  }
                } else if (m) {
                  ttr.nextSymbol();
                  if (!options.bymonth)
                    options.bymonth = [];
                  options.bymonth.push(m);
                } else {
                  return;
                }
              } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
            }
            function AT() {
              var at = ttr.accept("at");
              if (!at)
                return;
              do {
                var n = ttr.acceptNumber();
                if (!n) {
                  throw new Error("Unexpected symbol " + ttr.symbol + ", expected hour");
                }
                options.byhour = [parseInt(n[0], 10)];
                while (ttr.accept("comma")) {
                  n = ttr.acceptNumber();
                  if (!n) {
                    throw new Error("Unexpected symbol " + ttr.symbol + "; expected hour");
                  }
                  options.byhour.push(parseInt(n[0], 10));
                }
              } while (ttr.accept("comma") || ttr.accept("at"));
            }
            function decodeM() {
              switch (ttr.symbol) {
                case "january":
                  return 1;
                case "february":
                  return 2;
                case "march":
                  return 3;
                case "april":
                  return 4;
                case "may":
                  return 5;
                case "june":
                  return 6;
                case "july":
                  return 7;
                case "august":
                  return 8;
                case "september":
                  return 9;
                case "october":
                  return 10;
                case "november":
                  return 11;
                case "december":
                  return 12;
                default:
                  return false;
              }
            }
            function decodeWKD() {
              switch (ttr.symbol) {
                case "monday":
                case "tuesday":
                case "wednesday":
                case "thursday":
                case "friday":
                case "saturday":
                case "sunday":
                  return ttr.symbol.substr(0, 2).toUpperCase();
                default:
                  return false;
              }
            }
            function decodeNTH() {
              switch (ttr.symbol) {
                case "last":
                  ttr.nextSymbol();
                  return -1;
                case "first":
                  ttr.nextSymbol();
                  return 1;
                case "second":
                  ttr.nextSymbol();
                  return ttr.accept("last") ? -2 : 2;
                case "third":
                  ttr.nextSymbol();
                  return ttr.accept("last") ? -3 : 3;
                case "nth":
                  var v = parseInt(ttr.value[1], 10);
                  if (v < -366 || v > 366)
                    throw new Error("Nth out of range: " + v);
                  ttr.nextSymbol();
                  return ttr.accept("last") ? -v : v;
                default:
                  return false;
              }
            }
            function MDAYs() {
              ttr.accept("on");
              ttr.accept("the");
              var nth = decodeNTH();
              if (!nth)
                return;
              options.bymonthday = [nth];
              ttr.nextSymbol();
              while (ttr.accept("comma")) {
                nth = decodeNTH();
                if (!nth) {
                  throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
                }
                options.bymonthday.push(nth);
                ttr.nextSymbol();
              }
            }
            function F() {
              if (ttr.symbol === "until") {
                var date = Date.parse(ttr.text);
                if (!date)
                  throw new Error("Cannot parse until date:" + ttr.text);
                options.until = new Date(date);
              } else if (ttr.accept("for")) {
                options.count = parseInt(ttr.value[0], 10);
                ttr.expect("number");
              }
            }
          }
          ;
          var Frequency;
          (function(Frequency2) {
            Frequency2[Frequency2["YEARLY"] = 0] = "YEARLY";
            Frequency2[Frequency2["MONTHLY"] = 1] = "MONTHLY";
            Frequency2[Frequency2["WEEKLY"] = 2] = "WEEKLY";
            Frequency2[Frequency2["DAILY"] = 3] = "DAILY";
            Frequency2[Frequency2["HOURLY"] = 4] = "HOURLY";
            Frequency2[Frequency2["MINUTELY"] = 5] = "MINUTELY";
            Frequency2[Frequency2["SECONDLY"] = 6] = "SECONDLY";
          })(Frequency || (Frequency = {}));
          function freqIsDailyOrGreater(freq) {
            return freq < Frequency.HOURLY;
          }
          ;
          var fromText = function(text, language) {
            if (language === void 0) {
              language = i18n;
            }
            return new RRule2(parseText(text, language) || void 0);
          };
          var common = [
            "count",
            "until",
            "interval",
            "byweekday",
            "bymonthday",
            "bymonth"
          ];
          totext.IMPLEMENTED = [];
          totext.IMPLEMENTED[Frequency.HOURLY] = common;
          totext.IMPLEMENTED[Frequency.MINUTELY] = common;
          totext.IMPLEMENTED[Frequency.DAILY] = ["byhour"].concat(common);
          totext.IMPLEMENTED[Frequency.WEEKLY] = common;
          totext.IMPLEMENTED[Frequency.MONTHLY] = common;
          totext.IMPLEMENTED[Frequency.YEARLY] = ["byweekno", "byyearday"].concat(common);
          var toText = function(rrule, gettext, language, dateFormatter) {
            return new totext(rrule, gettext, language, dateFormatter).toString();
          };
          var isFullyConvertible = totext.isFullyConvertible;
          ;
          var Time = (
            /** @class */
            (function() {
              function Time2(hour, minute, second, millisecond) {
                this.hour = hour;
                this.minute = minute;
                this.second = second;
                this.millisecond = millisecond || 0;
              }
              Time2.prototype.getHours = function() {
                return this.hour;
              };
              Time2.prototype.getMinutes = function() {
                return this.minute;
              };
              Time2.prototype.getSeconds = function() {
                return this.second;
              };
              Time2.prototype.getMilliseconds = function() {
                return this.millisecond;
              };
              Time2.prototype.getTime = function() {
                return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
              };
              return Time2;
            })()
          );
          var DateTime = (
            /** @class */
            (function(_super) {
              __extends(DateTime2, _super);
              function DateTime2(year, month, day, hour, minute, second, millisecond) {
                var _this = _super.call(this, hour, minute, second, millisecond) || this;
                _this.year = year;
                _this.month = month;
                _this.day = day;
                return _this;
              }
              DateTime2.fromDate = function(date) {
                return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1e3);
              };
              DateTime2.prototype.getWeekday = function() {
                return getWeekday(new Date(this.getTime()));
              };
              DateTime2.prototype.getTime = function() {
                return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
              };
              DateTime2.prototype.getDay = function() {
                return this.day;
              };
              DateTime2.prototype.getMonth = function() {
                return this.month;
              };
              DateTime2.prototype.getYear = function() {
                return this.year;
              };
              DateTime2.prototype.addYears = function(years) {
                this.year += years;
              };
              DateTime2.prototype.addMonths = function(months) {
                this.month += months;
                if (this.month > 12) {
                  var yearDiv = Math.floor(this.month / 12);
                  var monthMod = pymod(this.month, 12);
                  this.month = monthMod;
                  this.year += yearDiv;
                  if (this.month === 0) {
                    this.month = 12;
                    --this.year;
                  }
                }
              };
              DateTime2.prototype.addWeekly = function(days, wkst) {
                if (wkst > this.getWeekday()) {
                  this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days * 7;
                } else {
                  this.day += -(this.getWeekday() - wkst) + days * 7;
                }
                this.fixDay();
              };
              DateTime2.prototype.addDaily = function(days) {
                this.day += days;
                this.fixDay();
              };
              DateTime2.prototype.addHours = function(hours, filtered, byhour) {
                if (filtered) {
                  this.hour += Math.floor((23 - this.hour) / hours) * hours;
                }
                for (; ; ) {
                  this.hour += hours;
                  var _a = divmod(this.hour, 24), dayDiv = _a.div, hourMod = _a.mod;
                  if (dayDiv) {
                    this.hour = hourMod;
                    this.addDaily(dayDiv);
                  }
                  if (empty(byhour) || includes(byhour, this.hour))
                    break;
                }
              };
              DateTime2.prototype.addMinutes = function(minutes, filtered, byhour, byminute) {
                if (filtered) {
                  this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes) * minutes;
                }
                for (; ; ) {
                  this.minute += minutes;
                  var _a = divmod(this.minute, 60), hourDiv = _a.div, minuteMod = _a.mod;
                  if (hourDiv) {
                    this.minute = minuteMod;
                    this.addHours(hourDiv, false, byhour);
                  }
                  if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute))) {
                    break;
                  }
                }
              };
              DateTime2.prototype.addSeconds = function(seconds, filtered, byhour, byminute, bysecond) {
                if (filtered) {
                  this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / seconds) * seconds;
                }
                for (; ; ) {
                  this.second += seconds;
                  var _a = divmod(this.second, 60), minuteDiv = _a.div, secondMod = _a.mod;
                  if (minuteDiv) {
                    this.second = secondMod;
                    this.addMinutes(minuteDiv, false, byhour, byminute);
                  }
                  if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute)) && (empty(bysecond) || includes(bysecond, this.second))) {
                    break;
                  }
                }
              };
              DateTime2.prototype.fixDay = function() {
                if (this.day <= 28) {
                  return;
                }
                var daysinmonth = monthRange(this.year, this.month - 1)[1];
                if (this.day <= daysinmonth) {
                  return;
                }
                while (this.day > daysinmonth) {
                  this.day -= daysinmonth;
                  ++this.month;
                  if (this.month === 13) {
                    this.month = 1;
                    ++this.year;
                    if (this.year > MAXYEAR) {
                      return;
                    }
                  }
                  daysinmonth = monthRange(this.year, this.month - 1)[1];
                }
              };
              DateTime2.prototype.add = function(options, filtered) {
                var freq = options.freq, interval = options.interval, wkst = options.wkst, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
                switch (freq) {
                  case Frequency.YEARLY:
                    return this.addYears(interval);
                  case Frequency.MONTHLY:
                    return this.addMonths(interval);
                  case Frequency.WEEKLY:
                    return this.addWeekly(interval, wkst);
                  case Frequency.DAILY:
                    return this.addDaily(interval);
                  case Frequency.HOURLY:
                    return this.addHours(interval, filtered, byhour);
                  case Frequency.MINUTELY:
                    return this.addMinutes(interval, filtered, byhour, byminute);
                  case Frequency.SECONDLY:
                    return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
                }
              };
              return DateTime2;
            })(Time)
          );
          ;
          function initializeOptions(options) {
            var invalid = [];
            var keys = Object.keys(options);
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
              var key = keys_1[_i];
              if (!includes(defaultKeys, key))
                invalid.push(key);
              if (isDate(options[key]) && !isValidDate(options[key])) {
                invalid.push(key);
              }
            }
            if (invalid.length) {
              throw new Error("Invalid options: " + invalid.join(", "));
            }
            return __assign({}, options);
          }
          function parseOptions(options) {
            var opts = __assign(__assign({}, DEFAULT_OPTIONS), initializeOptions(options));
            if (isPresent(opts.byeaster))
              opts.freq = RRule2.YEARLY;
            if (!(isPresent(opts.freq) && RRule2.FREQUENCIES[opts.freq])) {
              throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options.freq));
            }
            if (!opts.dtstart)
              opts.dtstart = new Date((/* @__PURE__ */ new Date()).setMilliseconds(0));
            if (!isPresent(opts.wkst)) {
              opts.wkst = RRule2.MO.weekday;
            } else if (isNumber(opts.wkst)) {
            } else {
              opts.wkst = opts.wkst.weekday;
            }
            if (isPresent(opts.bysetpos)) {
              if (isNumber(opts.bysetpos))
                opts.bysetpos = [opts.bysetpos];
              for (var i = 0; i < opts.bysetpos.length; i++) {
                var v = opts.bysetpos[i];
                if (v === 0 || !(v >= -366 && v <= 366)) {
                  throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
                }
              }
            }
            if (!(Boolean(opts.byweekno) || notEmpty(opts.byweekno) || notEmpty(opts.byyearday) || Boolean(opts.bymonthday) || notEmpty(opts.bymonthday) || isPresent(opts.byweekday) || isPresent(opts.byeaster))) {
              switch (opts.freq) {
                case RRule2.YEARLY:
                  if (!opts.bymonth)
                    opts.bymonth = opts.dtstart.getUTCMonth() + 1;
                  opts.bymonthday = opts.dtstart.getUTCDate();
                  break;
                case RRule2.MONTHLY:
                  opts.bymonthday = opts.dtstart.getUTCDate();
                  break;
                case RRule2.WEEKLY:
                  opts.byweekday = [getWeekday(opts.dtstart)];
                  break;
              }
            }
            if (isPresent(opts.bymonth) && !isArray(opts.bymonth)) {
              opts.bymonth = [opts.bymonth];
            }
            if (isPresent(opts.byyearday) && !isArray(opts.byyearday) && isNumber(opts.byyearday)) {
              opts.byyearday = [opts.byyearday];
            }
            if (!isPresent(opts.bymonthday)) {
              opts.bymonthday = [];
              opts.bynmonthday = [];
            } else if (isArray(opts.bymonthday)) {
              var bymonthday = [];
              var bynmonthday = [];
              for (var i = 0; i < opts.bymonthday.length; i++) {
                var v = opts.bymonthday[i];
                if (v > 0) {
                  bymonthday.push(v);
                } else if (v < 0) {
                  bynmonthday.push(v);
                }
              }
              opts.bymonthday = bymonthday;
              opts.bynmonthday = bynmonthday;
            } else if (opts.bymonthday < 0) {
              opts.bynmonthday = [opts.bymonthday];
              opts.bymonthday = [];
            } else {
              opts.bynmonthday = [];
              opts.bymonthday = [opts.bymonthday];
            }
            if (isPresent(opts.byweekno) && !isArray(opts.byweekno)) {
              opts.byweekno = [opts.byweekno];
            }
            if (!isPresent(opts.byweekday)) {
              opts.bynweekday = null;
            } else if (isNumber(opts.byweekday)) {
              opts.byweekday = [opts.byweekday];
              opts.bynweekday = null;
            } else if (isWeekdayStr(opts.byweekday)) {
              opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
              opts.bynweekday = null;
            } else if (opts.byweekday instanceof Weekday) {
              if (!opts.byweekday.n || opts.freq > RRule2.MONTHLY) {
                opts.byweekday = [opts.byweekday.weekday];
                opts.bynweekday = null;
              } else {
                opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
                opts.byweekday = null;
              }
            } else {
              var byweekday = [];
              var bynweekday = [];
              for (var i = 0; i < opts.byweekday.length; i++) {
                var wday = opts.byweekday[i];
                if (isNumber(wday)) {
                  byweekday.push(wday);
                  continue;
                } else if (isWeekdayStr(wday)) {
                  byweekday.push(Weekday.fromStr(wday).weekday);
                  continue;
                }
                if (!wday.n || opts.freq > RRule2.MONTHLY) {
                  byweekday.push(wday.weekday);
                } else {
                  bynweekday.push([wday.weekday, wday.n]);
                }
              }
              opts.byweekday = notEmpty(byweekday) ? byweekday : null;
              opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
            }
            if (!isPresent(opts.byhour)) {
              opts.byhour = opts.freq < RRule2.HOURLY ? [opts.dtstart.getUTCHours()] : null;
            } else if (isNumber(opts.byhour)) {
              opts.byhour = [opts.byhour];
            }
            if (!isPresent(opts.byminute)) {
              opts.byminute = opts.freq < RRule2.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
            } else if (isNumber(opts.byminute)) {
              opts.byminute = [opts.byminute];
            }
            if (!isPresent(opts.bysecond)) {
              opts.bysecond = opts.freq < RRule2.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
            } else if (isNumber(opts.bysecond)) {
              opts.bysecond = [opts.bysecond];
            }
            return { parsedOptions: opts };
          }
          function buildTimeset(opts) {
            var millisecondModulo = opts.dtstart.getTime() % 1e3;
            if (!freqIsDailyOrGreater(opts.freq)) {
              return [];
            }
            var timeset = [];
            opts.byhour.forEach(function(hour) {
              opts.byminute.forEach(function(minute) {
                opts.bysecond.forEach(function(second) {
                  timeset.push(new Time(hour, minute, second, millisecondModulo));
                });
              });
            });
            return timeset;
          }
          ;
          function parseString(rfcString) {
            var options = rfcString.split("\n").map(parseLine).filter(function(x) {
              return x !== null;
            });
            return __assign(__assign({}, options[0]), options[1]);
          }
          function parseDtstart(line) {
            var options = {};
            var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
            if (!dtstartWithZone) {
              return options;
            }
            var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
            if (tzid) {
              options.tzid = tzid;
            }
            options.dtstart = untilStringToDate(dtstart);
            return options;
          }
          function parseLine(rfcString) {
            rfcString = rfcString.replace(/^\s+|\s+$/, "");
            if (!rfcString.length)
              return null;
            var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
            if (!header) {
              return parseRrule(rfcString);
            }
            var key = header[1];
            switch (key.toUpperCase()) {
              case "RRULE":
              case "EXRULE":
                return parseRrule(rfcString);
              case "DTSTART":
                return parseDtstart(rfcString);
              default:
                throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
            }
          }
          function parseRrule(line) {
            var strippedLine = line.replace(/^RRULE:/i, "");
            var options = parseDtstart(strippedLine);
            var attrs = line.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
            attrs.forEach(function(attr) {
              var _a = attr.split("="), key = _a[0], value = _a[1];
              switch (key.toUpperCase()) {
                case "FREQ":
                  options.freq = Frequency[value.toUpperCase()];
                  break;
                case "WKST":
                  options.wkst = Days[value.toUpperCase()];
                  break;
                case "COUNT":
                case "INTERVAL":
                case "BYSETPOS":
                case "BYMONTH":
                case "BYMONTHDAY":
                case "BYYEARDAY":
                case "BYWEEKNO":
                case "BYHOUR":
                case "BYMINUTE":
                case "BYSECOND":
                  var num = parseNumber(value);
                  var optionKey = key.toLowerCase();
                  options[optionKey] = num;
                  break;
                case "BYWEEKDAY":
                case "BYDAY":
                  options.byweekday = parseWeekday(value);
                  break;
                case "DTSTART":
                case "TZID":
                  var dtstart = parseDtstart(line);
                  options.tzid = dtstart.tzid;
                  options.dtstart = dtstart.dtstart;
                  break;
                case "UNTIL":
                  options.until = untilStringToDate(value);
                  break;
                case "BYEASTER":
                  options.byeaster = Number(value);
                  break;
                default:
                  throw new Error("Unknown RRULE property '" + key + "'");
              }
            });
            return options;
          }
          function parseNumber(value) {
            if (value.indexOf(",") !== -1) {
              var values = value.split(",");
              return values.map(parseIndividualNumber);
            }
            return parseIndividualNumber(value);
          }
          function parseIndividualNumber(value) {
            if (/^[+-]?\d+$/.test(value)) {
              return Number(value);
            }
            return value;
          }
          function parseWeekday(value) {
            var days = value.split(",");
            return days.map(function(day) {
              if (day.length === 2) {
                return Days[day];
              }
              var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
              if (!parts || parts.length < 3) {
                throw new SyntaxError("Invalid weekday string: ".concat(day));
              }
              var n = Number(parts[1]);
              var wdaypart = parts[2];
              var wday = Days[wdaypart].weekday;
              return new Weekday(wday, n);
            });
          }
          ;
          var DateWithZone = (
            /** @class */
            (function() {
              function DateWithZone2(date, tzid) {
                if (isNaN(date.getTime())) {
                  throw new RangeError("Invalid date passed to DateWithZone");
                }
                this.date = date;
                this.tzid = tzid;
              }
              Object.defineProperty(DateWithZone2.prototype, "isUTC", {
                get: function() {
                  return !this.tzid || this.tzid.toUpperCase() === "UTC";
                },
                enumerable: false,
                configurable: true
              });
              DateWithZone2.prototype.toString = function() {
                var datestr = timeToUntilString(this.date.getTime(), this.isUTC);
                if (!this.isUTC) {
                  return ";TZID=".concat(this.tzid, ":").concat(datestr);
                }
                return ":".concat(datestr);
              };
              DateWithZone2.prototype.getTime = function() {
                return this.date.getTime();
              };
              DateWithZone2.prototype.rezonedDate = function() {
                if (this.isUTC) {
                  return this.date;
                }
                return dateInTimeZone(this.date, this.tzid);
              };
              return DateWithZone2;
            })()
          );
          ;
          function optionsToString(options) {
            var rrule = [];
            var dtstart = "";
            var keys = Object.keys(options);
            var defaultKeys2 = Object.keys(DEFAULT_OPTIONS);
            for (var i = 0; i < keys.length; i++) {
              if (keys[i] === "tzid")
                continue;
              if (!includes(defaultKeys2, keys[i]))
                continue;
              var key = keys[i].toUpperCase();
              var value = options[keys[i]];
              var outValue = "";
              if (!isPresent(value) || isArray(value) && !value.length)
                continue;
              switch (key) {
                case "FREQ":
                  outValue = RRule2.FREQUENCIES[options.freq];
                  break;
                case "WKST":
                  if (isNumber(value)) {
                    outValue = new Weekday(value).toString();
                  } else {
                    outValue = value.toString();
                  }
                  break;
                case "BYWEEKDAY":
                  key = "BYDAY";
                  outValue = toArray(value).map(function(wday) {
                    if (wday instanceof Weekday) {
                      return wday;
                    }
                    if (isArray(wday)) {
                      return new Weekday(wday[0], wday[1]);
                    }
                    return new Weekday(wday);
                  }).toString();
                  break;
                case "DTSTART":
                  dtstart = buildDtstart(value, options.tzid);
                  break;
                case "UNTIL":
                  outValue = timeToUntilString(value, !options.tzid);
                  break;
                default:
                  if (isArray(value)) {
                    var strValues = [];
                    for (var j = 0; j < value.length; j++) {
                      strValues[j] = String(value[j]);
                    }
                    outValue = strValues.toString();
                  } else {
                    outValue = String(value);
                  }
              }
              if (outValue) {
                rrule.push([key, outValue]);
              }
            }
            var rules = rrule.map(function(_a) {
              var key2 = _a[0], value2 = _a[1];
              return "".concat(key2, "=").concat(value2.toString());
            }).join(";");
            var ruleString = "";
            if (rules !== "") {
              ruleString = "RRULE:".concat(rules);
            }
            return [dtstart, ruleString].filter(function(x) {
              return !!x;
            }).join("\n");
          }
          function buildDtstart(dtstart, tzid) {
            if (!dtstart) {
              return "";
            }
            return "DTSTART" + new DateWithZone(new Date(dtstart), tzid).toString();
          }
          ;
          function argsMatch(left, right) {
            if (Array.isArray(left)) {
              if (!Array.isArray(right))
                return false;
              if (left.length !== right.length)
                return false;
              return left.every(function(date, i) {
                return date.getTime() === right[i].getTime();
              });
            }
            if (left instanceof Date) {
              return right instanceof Date && left.getTime() === right.getTime();
            }
            return left === right;
          }
          var Cache = (
            /** @class */
            (function() {
              function Cache2() {
                this.all = false;
                this.before = [];
                this.after = [];
                this.between = [];
              }
              Cache2.prototype._cacheAdd = function(what, value, args) {
                if (value) {
                  value = value instanceof Date ? dateutil_clone(value) : cloneDates(value);
                }
                if (what === "all") {
                  this.all = value;
                } else {
                  args._value = value;
                  this[what].push(args);
                }
              };
              Cache2.prototype._cacheGet = function(what, args) {
                var cached = false;
                var argsKeys = args ? Object.keys(args) : [];
                var findCacheDiff = function(item2) {
                  for (var i2 = 0; i2 < argsKeys.length; i2++) {
                    var key = argsKeys[i2];
                    if (!argsMatch(args[key], item2[key])) {
                      return true;
                    }
                  }
                  return false;
                };
                var cachedObject = this[what];
                if (what === "all") {
                  cached = this.all;
                } else if (isArray(cachedObject)) {
                  for (var i = 0; i < cachedObject.length; i++) {
                    var item = cachedObject[i];
                    if (argsKeys.length && findCacheDiff(item))
                      continue;
                    cached = item._value;
                    break;
                  }
                }
                if (!cached && this.all) {
                  var iterResult = new iterresult(what, args);
                  for (var i = 0; i < this.all.length; i++) {
                    if (!iterResult.accept(this.all[i]))
                      break;
                  }
                  cached = iterResult.getValue();
                  this._cacheAdd(what, cached, args);
                }
                return isArray(cached) ? cloneDates(cached) : cached instanceof Date ? dateutil_clone(cached) : cached;
              };
              return Cache2;
            })()
          );
          ;
          var M365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
          var M366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
          var M28 = range(1, 29);
          var M29 = range(1, 30);
          var M30 = range(1, 31);
          var M31 = range(1, 32);
          var MDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
          var MDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
          var NM28 = range(-28, 0);
          var NM29 = range(-29, 0);
          var NM30 = range(-30, 0);
          var NM31 = range(-31, 0);
          var NMDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
          var NMDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
          var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
          var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
          var WDAYMASK = (function() {
            var wdaymask = [];
            for (var i = 0; i < 55; i++)
              wdaymask = wdaymask.concat(range(7));
            return wdaymask;
          })();
          ;
          function rebuildYear(year, options) {
            var firstyday = datetime(year, 1, 1);
            var yearlen = isLeapYear(year) ? 366 : 365;
            var nextyearlen = isLeapYear(year + 1) ? 366 : 365;
            var yearordinal = toOrdinal(firstyday);
            var yearweekday = getWeekday(firstyday);
            var result = __assign(__assign({ yearlen, nextyearlen, yearordinal, yearweekday }, baseYearMasks(year)), { wnomask: null });
            if (empty(options.byweekno)) {
              return result;
            }
            result.wnomask = repeat(0, yearlen + 7);
            var firstwkst;
            var wyearlen;
            var no1wkst = firstwkst = pymod(7 - yearweekday + options.wkst, 7);
            if (no1wkst >= 4) {
              no1wkst = 0;
              wyearlen = result.yearlen + pymod(yearweekday - options.wkst, 7);
            } else {
              wyearlen = yearlen - no1wkst;
            }
            var div = Math.floor(wyearlen / 7);
            var mod = pymod(wyearlen, 7);
            var numweeks = Math.floor(div + mod / 4);
            for (var j = 0; j < options.byweekno.length; j++) {
              var n = options.byweekno[j];
              if (n < 0) {
                n += numweeks + 1;
              }
              if (!(n > 0 && n <= numweeks)) {
                continue;
              }
              var i = void 0;
              if (n > 1) {
                i = no1wkst + (n - 1) * 7;
                if (no1wkst !== firstwkst) {
                  i -= 7 - firstwkst;
                }
              } else {
                i = no1wkst;
              }
              for (var k = 0; k < 7; k++) {
                result.wnomask[i] = 1;
                i++;
                if (result.wdaymask[i] === options.wkst)
                  break;
              }
            }
            if (includes(options.byweekno, 1)) {
              var i = no1wkst + numweeks * 7;
              if (no1wkst !== firstwkst)
                i -= 7 - firstwkst;
              if (i < yearlen) {
                for (var j = 0; j < 7; j++) {
                  result.wnomask[i] = 1;
                  i += 1;
                  if (result.wdaymask[i] === options.wkst)
                    break;
                }
              }
            }
            if (no1wkst) {
              var lnumweeks = void 0;
              if (!includes(options.byweekno, -1)) {
                var lyearweekday = getWeekday(datetime(year - 1, 1, 1));
                var lno1wkst = pymod(7 - lyearweekday.valueOf() + options.wkst, 7);
                var lyearlen = isLeapYear(year - 1) ? 366 : 365;
                var weekst = void 0;
                if (lno1wkst >= 4) {
                  lno1wkst = 0;
                  weekst = lyearlen + pymod(lyearweekday - options.wkst, 7);
                } else {
                  weekst = yearlen - no1wkst;
                }
                lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
              } else {
                lnumweeks = -1;
              }
              if (includes(options.byweekno, lnumweeks)) {
                for (var i = 0; i < no1wkst; i++)
                  result.wnomask[i] = 1;
              }
            }
            return result;
          }
          function baseYearMasks(year) {
            var yearlen = isLeapYear(year) ? 366 : 365;
            var firstyday = datetime(year, 1, 1);
            var wday = getWeekday(firstyday);
            if (yearlen === 365) {
              return {
                mmask: M365MASK,
                mdaymask: MDAY365MASK,
                nmdaymask: NMDAY365MASK,
                wdaymask: WDAYMASK.slice(wday),
                mrange: M365RANGE
              };
            }
            return {
              mmask: M366MASK,
              mdaymask: MDAY366MASK,
              nmdaymask: NMDAY366MASK,
              wdaymask: WDAYMASK.slice(wday),
              mrange: M366RANGE
            };
          }
          ;
          function rebuildMonth(year, month, yearlen, mrange, wdaymask, options) {
            var result = {
              lastyear: year,
              lastmonth: month,
              nwdaymask: []
            };
            var ranges = [];
            if (options.freq === RRule2.YEARLY) {
              if (empty(options.bymonth)) {
                ranges = [[0, yearlen]];
              } else {
                for (var j = 0; j < options.bymonth.length; j++) {
                  month = options.bymonth[j];
                  ranges.push(mrange.slice(month - 1, month + 1));
                }
              }
            } else if (options.freq === RRule2.MONTHLY) {
              ranges = [mrange.slice(month - 1, month + 1)];
            }
            if (empty(ranges)) {
              return result;
            }
            result.nwdaymask = repeat(0, yearlen);
            for (var j = 0; j < ranges.length; j++) {
              var rang = ranges[j];
              var first = rang[0];
              var last = rang[1] - 1;
              for (var k = 0; k < options.bynweekday.length; k++) {
                var i = void 0;
                var _a = options.bynweekday[k], wday = _a[0], n = _a[1];
                if (n < 0) {
                  i = last + (n + 1) * 7;
                  i -= pymod(wdaymask[i] - wday, 7);
                } else {
                  i = first + (n - 1) * 7;
                  i += pymod(7 - wdaymask[i] + wday, 7);
                }
                if (first <= i && i <= last)
                  result.nwdaymask[i] = 1;
              }
            }
            return result;
          }
          ;
          function easter(y, offset) {
            if (offset === void 0) {
              offset = 0;
            }
            var a = y % 19;
            var b = Math.floor(y / 100);
            var c = y % 100;
            var d = Math.floor(b / 4);
            var e = b % 4;
            var f = Math.floor((b + 8) / 25);
            var g = Math.floor((b - f + 1) / 3);
            var h = Math.floor(19 * a + b - d - g + 15) % 30;
            var i = Math.floor(c / 4);
            var k = c % 4;
            var l = Math.floor(32 + 2 * e + 2 * i - h - k) % 7;
            var m = Math.floor((a + 11 * h + 22 * l) / 451);
            var month = Math.floor((h + l - 7 * m + 114) / 31);
            var day = (h + l - 7 * m + 114) % 31 + 1;
            var date = Date.UTC(y, month - 1, day + offset);
            var yearStart = Date.UTC(y, 0, 1);
            return [Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24))];
          }
          ;
          var Iterinfo = (
            /** @class */
            (function() {
              function Iterinfo2(options) {
                this.options = options;
              }
              Iterinfo2.prototype.rebuild = function(year, month) {
                var options = this.options;
                if (year !== this.lastyear) {
                  this.yearinfo = rebuildYear(year, options);
                }
                if (notEmpty(options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
                  var _a = this.yearinfo, yearlen = _a.yearlen, mrange = _a.mrange, wdaymask = _a.wdaymask;
                  this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options);
                }
                if (isPresent(options.byeaster)) {
                  this.eastermask = easter(year, options.byeaster);
                }
              };
              Object.defineProperty(Iterinfo2.prototype, "lastyear", {
                get: function() {
                  return this.monthinfo ? this.monthinfo.lastyear : null;
                },
                enumerable: false,
                configurable: true
              });
              Object.defineProperty(Iterinfo2.prototype, "lastmonth", {
                get: function() {
                  return this.monthinfo ? this.monthinfo.lastmonth : null;
                },
                enumerable: false,
                configurable: true
              });
              Object.defineProperty(Iterinfo2.prototype, "yearlen", {
                get: function() {
                  return this.yearinfo.yearlen;
                },
                enumerable: false,
                configurable: true
              });
              Object.defineProperty(Iterinfo2.prototype, "yearordinal", {
                get: function() {
                  return this.yearinfo.yearordinal;
                },
                enumerable: false,
                configurable: true
              });
              Object.defineProperty(Iterinfo2.prototype, "mrange", {
                get: function() {
                  return this.yearinfo.mrange;
                },
                enumerable: false,
                configurable: true
              });
              Object.defineProperty(Iterinfo2.prototype, "wdaymask", {
                get: function() {
                  return this.yearinfo.wdaymask;
                },
                enumerable: false,
                configurable: true
              });
              Object.defineProperty(Iterinfo2.prototype, "mmask", {
                get: function() {
                  return this.yearinfo.mmask;
                },
                enumerable: false,
                configurable: true
              });
              Object.defineProperty(Iterinfo2.prototype, "wnomask", {
                get: function() {
                  return this.yearinfo.wnomask;
                },
                enumerable: false,
                configurable: true
              });
              Object.defineProperty(Iterinfo2.prototype, "nwdaymask", {
                get: function() {
                  return this.monthinfo ? this.monthinfo.nwdaymask : [];
                },
                enumerable: false,
                configurable: true
              });
              Object.defineProperty(Iterinfo2.prototype, "nextyearlen", {
                get: function() {
                  return this.yearinfo.nextyearlen;
                },
                enumerable: false,
                configurable: true
              });
              Object.defineProperty(Iterinfo2.prototype, "mdaymask", {
                get: function() {
                  return this.yearinfo.mdaymask;
                },
                enumerable: false,
                configurable: true
              });
              Object.defineProperty(Iterinfo2.prototype, "nmdaymask", {
                get: function() {
                  return this.yearinfo.nmdaymask;
                },
                enumerable: false,
                configurable: true
              });
              Iterinfo2.prototype.ydayset = function() {
                return [range(this.yearlen), 0, this.yearlen];
              };
              Iterinfo2.prototype.mdayset = function(_, month) {
                var start = this.mrange[month - 1];
                var end = this.mrange[month];
                var set = repeat(null, this.yearlen);
                for (var i = start; i < end; i++)
                  set[i] = i;
                return [set, start, end];
              };
              Iterinfo2.prototype.wdayset = function(year, month, day) {
                var set = repeat(null, this.yearlen + 7);
                var i = toOrdinal(datetime(year, month, day)) - this.yearordinal;
                var start = i;
                for (var j = 0; j < 7; j++) {
                  set[i] = i;
                  ++i;
                  if (this.wdaymask[i] === this.options.wkst)
                    break;
                }
                return [set, start, i];
              };
              Iterinfo2.prototype.ddayset = function(year, month, day) {
                var set = repeat(null, this.yearlen);
                var i = toOrdinal(datetime(year, month, day)) - this.yearordinal;
                set[i] = i;
                return [set, i, i + 1];
              };
              Iterinfo2.prototype.htimeset = function(hour, _, second, millisecond) {
                var _this = this;
                var set = [];
                this.options.byminute.forEach(function(minute) {
                  set = set.concat(_this.mtimeset(hour, minute, second, millisecond));
                });
                sort(set);
                return set;
              };
              Iterinfo2.prototype.mtimeset = function(hour, minute, _, millisecond) {
                var set = this.options.bysecond.map(function(second) {
                  return new Time(hour, minute, second, millisecond);
                });
                sort(set);
                return set;
              };
              Iterinfo2.prototype.stimeset = function(hour, minute, second, millisecond) {
                return [new Time(hour, minute, second, millisecond)];
              };
              Iterinfo2.prototype.getdayset = function(freq) {
                switch (freq) {
                  case Frequency.YEARLY:
                    return this.ydayset.bind(this);
                  case Frequency.MONTHLY:
                    return this.mdayset.bind(this);
                  case Frequency.WEEKLY:
                    return this.wdayset.bind(this);
                  case Frequency.DAILY:
                    return this.ddayset.bind(this);
                  default:
                    return this.ddayset.bind(this);
                }
              };
              Iterinfo2.prototype.gettimeset = function(freq) {
                switch (freq) {
                  case Frequency.HOURLY:
                    return this.htimeset.bind(this);
                  case Frequency.MINUTELY:
                    return this.mtimeset.bind(this);
                  case Frequency.SECONDLY:
                    return this.stimeset.bind(this);
                }
              };
              return Iterinfo2;
            })()
          );
          const iterinfo = Iterinfo;
          ;
          function buildPoslist(bysetpos, timeset, start, end, ii, dayset) {
            var poslist = [];
            for (var j = 0; j < bysetpos.length; j++) {
              var daypos = void 0;
              var timepos = void 0;
              var pos = bysetpos[j];
              if (pos < 0) {
                daypos = Math.floor(pos / timeset.length);
                timepos = pymod(pos, timeset.length);
              } else {
                daypos = Math.floor((pos - 1) / timeset.length);
                timepos = pymod(pos - 1, timeset.length);
              }
              var tmp = [];
              for (var k = start; k < end; k++) {
                var val = dayset[k];
                if (!isPresent(val))
                  continue;
                tmp.push(val);
              }
              var i = void 0;
              if (daypos < 0) {
                i = tmp.slice(daypos)[0];
              } else {
                i = tmp[daypos];
              }
              var time = timeset[timepos];
              var date = fromOrdinal(ii.yearordinal + i);
              var res = combine(date, time);
              if (!includes(poslist, res))
                poslist.push(res);
            }
            sort(poslist);
            return poslist;
          }
          ;
          function iter(iterResult, options) {
            var dtstart = options.dtstart, freq = options.freq, interval = options.interval, until = options.until, bysetpos = options.bysetpos;
            var count = options.count;
            if (count === 0 || interval === 0) {
              return emitResult(iterResult);
            }
            var counterDate = DateTime.fromDate(dtstart);
            var ii = new iterinfo(options);
            ii.rebuild(counterDate.year, counterDate.month);
            var timeset = makeTimeset(ii, counterDate, options);
            for (; ; ) {
              var _a = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a[0], start = _a[1], end = _a[2];
              var filtered = removeFilteredDays(dayset, start, end, ii, options);
              if (notEmpty(bysetpos)) {
                var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);
                for (var j = 0; j < poslist.length; j++) {
                  var res = poslist[j];
                  if (until && res > until) {
                    return emitResult(iterResult);
                  }
                  if (res >= dtstart) {
                    var rezonedDate = rezoneIfNeeded(res, options);
                    if (!iterResult.accept(rezonedDate)) {
                      return emitResult(iterResult);
                    }
                    if (count) {
                      --count;
                      if (!count) {
                        return emitResult(iterResult);
                      }
                    }
                  }
                }
              } else {
                for (var j = start; j < end; j++) {
                  var currentDay = dayset[j];
                  if (!isPresent(currentDay)) {
                    continue;
                  }
                  var date = fromOrdinal(ii.yearordinal + currentDay);
                  for (var k = 0; k < timeset.length; k++) {
                    var time = timeset[k];
                    var res = combine(date, time);
                    if (until && res > until) {
                      return emitResult(iterResult);
                    }
                    if (res >= dtstart) {
                      var rezonedDate = rezoneIfNeeded(res, options);
                      if (!iterResult.accept(rezonedDate)) {
                        return emitResult(iterResult);
                      }
                      if (count) {
                        --count;
                        if (!count) {
                          return emitResult(iterResult);
                        }
                      }
                    }
                  }
                }
              }
              if (options.interval === 0) {
                return emitResult(iterResult);
              }
              counterDate.add(options, filtered);
              if (counterDate.year > MAXYEAR) {
                return emitResult(iterResult);
              }
              if (!freqIsDailyOrGreater(freq)) {
                timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
              }
              ii.rebuild(counterDate.year, counterDate.month);
            }
          }
          function isFiltered(ii, currentDay, options) {
            var bymonth = options.bymonth, byweekno = options.byweekno, byweekday = options.byweekday, byeaster = options.byeaster, bymonthday = options.bymonthday, bynmonthday = options.bynmonthday, byyearday = options.byyearday;
            return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));
          }
          function rezoneIfNeeded(date, options) {
            return new DateWithZone(date, options.tzid).rezonedDate();
          }
          function emitResult(iterResult) {
            return iterResult.getValue();
          }
          function removeFilteredDays(dayset, start, end, ii, options) {
            var filtered = false;
            for (var dayCounter = start; dayCounter < end; dayCounter++) {
              var currentDay = dayset[dayCounter];
              filtered = isFiltered(ii, currentDay, options);
              if (filtered)
                dayset[currentDay] = null;
            }
            return filtered;
          }
          function makeTimeset(ii, counterDate, options) {
            var freq = options.freq, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
            if (freqIsDailyOrGreater(freq)) {
              return buildTimeset(options);
            }
            if (freq >= RRule2.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule2.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule2.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {
              return [];
            }
            return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
          }
          ;
          var Days = {
            MO: new Weekday(0),
            TU: new Weekday(1),
            WE: new Weekday(2),
            TH: new Weekday(3),
            FR: new Weekday(4),
            SA: new Weekday(5),
            SU: new Weekday(6)
          };
          var DEFAULT_OPTIONS = {
            freq: Frequency.YEARLY,
            dtstart: null,
            interval: 1,
            wkst: Days.MO,
            count: null,
            until: null,
            tzid: null,
            bysetpos: null,
            bymonth: null,
            bymonthday: null,
            bynmonthday: null,
            byyearday: null,
            byweekno: null,
            byweekday: null,
            bynweekday: null,
            byhour: null,
            byminute: null,
            bysecond: null,
            byeaster: null
          };
          var defaultKeys = Object.keys(DEFAULT_OPTIONS);
          var RRule2 = (
            /** @class */
            (function() {
              function RRule3(options, noCache) {
                if (options === void 0) {
                  options = {};
                }
                if (noCache === void 0) {
                  noCache = false;
                }
                this._cache = noCache ? null : new Cache();
                this.origOptions = initializeOptions(options);
                var parsedOptions = parseOptions(options).parsedOptions;
                this.options = parsedOptions;
              }
              RRule3.parseText = function(text, language) {
                return parseText(text, language);
              };
              RRule3.fromText = function(text, language) {
                return fromText(text, language);
              };
              RRule3.fromString = function(str) {
                return new RRule3(RRule3.parseString(str) || void 0);
              };
              RRule3.prototype._iter = function(iterResult) {
                return iter(iterResult, this.options);
              };
              RRule3.prototype._cacheGet = function(what, args) {
                if (!this._cache)
                  return false;
                return this._cache._cacheGet(what, args);
              };
              RRule3.prototype._cacheAdd = function(what, value, args) {
                if (!this._cache)
                  return;
                return this._cache._cacheAdd(what, value, args);
              };
              RRule3.prototype.all = function(iterator) {
                if (iterator) {
                  return this._iter(new callbackiterresult("all", {}, iterator));
                }
                var result = this._cacheGet("all");
                if (result === false) {
                  result = this._iter(new iterresult("all", {}));
                  this._cacheAdd("all", result);
                }
                return result;
              };
              RRule3.prototype.between = function(after, before, inc, iterator) {
                if (inc === void 0) {
                  inc = false;
                }
                if (!isValidDate(after) || !isValidDate(before)) {
                  throw new Error("Invalid date passed in to RRule.between");
                }
                var args = {
                  before,
                  after,
                  inc
                };
                if (iterator) {
                  return this._iter(new callbackiterresult("between", args, iterator));
                }
                var result = this._cacheGet("between", args);
                if (result === false) {
                  result = this._iter(new iterresult("between", args));
                  this._cacheAdd("between", result, args);
                }
                return result;
              };
              RRule3.prototype.before = function(dt, inc) {
                if (inc === void 0) {
                  inc = false;
                }
                if (!isValidDate(dt)) {
                  throw new Error("Invalid date passed in to RRule.before");
                }
                var args = { dt, inc };
                var result = this._cacheGet("before", args);
                if (result === false) {
                  result = this._iter(new iterresult("before", args));
                  this._cacheAdd("before", result, args);
                }
                return result;
              };
              RRule3.prototype.after = function(dt, inc) {
                if (inc === void 0) {
                  inc = false;
                }
                if (!isValidDate(dt)) {
                  throw new Error("Invalid date passed in to RRule.after");
                }
                var args = { dt, inc };
                var result = this._cacheGet("after", args);
                if (result === false) {
                  result = this._iter(new iterresult("after", args));
                  this._cacheAdd("after", result, args);
                }
                return result;
              };
              RRule3.prototype.count = function() {
                return this.all().length;
              };
              RRule3.prototype.toString = function() {
                return optionsToString(this.origOptions);
              };
              RRule3.prototype.toText = function(gettext, language, dateFormatter) {
                return toText(this, gettext, language, dateFormatter);
              };
              RRule3.prototype.isFullyConvertibleToText = function() {
                return isFullyConvertible(this);
              };
              RRule3.prototype.clone = function() {
                return new RRule3(this.origOptions);
              };
              RRule3.FREQUENCIES = [
                "YEARLY",
                "MONTHLY",
                "WEEKLY",
                "DAILY",
                "HOURLY",
                "MINUTELY",
                "SECONDLY"
              ];
              RRule3.YEARLY = Frequency.YEARLY;
              RRule3.MONTHLY = Frequency.MONTHLY;
              RRule3.WEEKLY = Frequency.WEEKLY;
              RRule3.DAILY = Frequency.DAILY;
              RRule3.HOURLY = Frequency.HOURLY;
              RRule3.MINUTELY = Frequency.MINUTELY;
              RRule3.SECONDLY = Frequency.SECONDLY;
              RRule3.MO = Days.MO;
              RRule3.TU = Days.TU;
              RRule3.WE = Days.WE;
              RRule3.TH = Days.TH;
              RRule3.FR = Days.FR;
              RRule3.SA = Days.SA;
              RRule3.SU = Days.SU;
              RRule3.parseString = parseString;
              RRule3.optionsToString = optionsToString;
              return RRule3;
            })()
          );
          ;
          function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
            var _exdateHash = {};
            var _accept = iterResult.accept;
            function evalExdate(after, before) {
              _exrule.forEach(function(rrule) {
                rrule.between(after, before, true).forEach(function(date) {
                  _exdateHash[Number(date)] = true;
                });
              });
            }
            _exdate.forEach(function(date) {
              var zonedDate2 = new DateWithZone(date, tzid).rezonedDate();
              _exdateHash[Number(zonedDate2)] = true;
            });
            iterResult.accept = function(date) {
              var dt = Number(date);
              if (isNaN(dt))
                return _accept.call(this, date);
              if (!_exdateHash[dt]) {
                evalExdate(new Date(dt - 1), new Date(dt + 1));
                if (!_exdateHash[dt]) {
                  _exdateHash[dt] = true;
                  return _accept.call(this, date);
                }
              }
              return true;
            };
            if (iterResult.method === "between") {
              evalExdate(iterResult.args.after, iterResult.args.before);
              iterResult.accept = function(date) {
                var dt = Number(date);
                if (!_exdateHash[dt]) {
                  _exdateHash[dt] = true;
                  return _accept.call(this, date);
                }
                return true;
              };
            }
            for (var i = 0; i < _rdate.length; i++) {
              var zonedDate = new DateWithZone(_rdate[i], tzid).rezonedDate();
              if (!iterResult.accept(new Date(zonedDate.getTime())))
                break;
            }
            _rrule.forEach(function(rrule) {
              iter(iterResult, rrule.options);
            });
            var res = iterResult._result;
            sort(res);
            switch (iterResult.method) {
              case "all":
              case "between":
                return res;
              case "before":
                return res.length && res[res.length - 1] || null;
              case "after":
              default:
                return res.length && res[0] || null;
            }
          }
          ;
          var rrulestr_DEFAULT_OPTIONS = {
            dtstart: null,
            cache: false,
            unfold: false,
            forceset: false,
            compatible: false,
            tzid: null
          };
          function parseInput(s, options) {
            var rrulevals = [];
            var rdatevals = [];
            var exrulevals = [];
            var exdatevals = [];
            var parsedDtstart = parseDtstart(s);
            var dtstart = parsedDtstart.dtstart;
            var tzid = parsedDtstart.tzid;
            var lines = splitIntoLines(s, options.unfold);
            lines.forEach(function(line) {
              var _a;
              if (!line)
                return;
              var _b = breakDownLine(line), name = _b.name, parms = _b.parms, value = _b.value;
              switch (name.toUpperCase()) {
                case "RRULE":
                  if (parms.length) {
                    throw new Error("unsupported RRULE parm: ".concat(parms.join(",")));
                  }
                  rrulevals.push(parseString(line));
                  break;
                case "RDATE":
                  var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [], rdateTzid = _c[1];
                  if (rdateTzid && !tzid) {
                    tzid = rdateTzid;
                  }
                  rdatevals = rdatevals.concat(parseRDate(value, parms));
                  break;
                case "EXRULE":
                  if (parms.length) {
                    throw new Error("unsupported EXRULE parm: ".concat(parms.join(",")));
                  }
                  exrulevals.push(parseString(value));
                  break;
                case "EXDATE":
                  exdatevals = exdatevals.concat(parseRDate(value, parms));
                  break;
                case "DTSTART":
                  break;
                default:
                  throw new Error("unsupported property: " + name);
              }
            });
            return {
              dtstart,
              tzid,
              rrulevals,
              rdatevals,
              exrulevals,
              exdatevals
            };
          }
          function buildRule(s, options) {
            var _a = parseInput(s, options), rrulevals = _a.rrulevals, rdatevals = _a.rdatevals, exrulevals = _a.exrulevals, exdatevals = _a.exdatevals, dtstart = _a.dtstart, tzid = _a.tzid;
            var noCache = options.cache === false;
            if (options.compatible) {
              options.forceset = true;
              options.unfold = true;
            }
            if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {
              var rset_1 = new RRuleSet2(noCache);
              rset_1.dtstart(dtstart);
              rset_1.tzid(tzid || void 0);
              rrulevals.forEach(function(val2) {
                rset_1.rrule(new RRule2(groomRruleOptions(val2, dtstart, tzid), noCache));
              });
              rdatevals.forEach(function(date) {
                rset_1.rdate(date);
              });
              exrulevals.forEach(function(val2) {
                rset_1.exrule(new RRule2(groomRruleOptions(val2, dtstart, tzid), noCache));
              });
              exdatevals.forEach(function(date) {
                rset_1.exdate(date);
              });
              if (options.compatible && options.dtstart)
                rset_1.rdate(dtstart);
              return rset_1;
            }
            var val = rrulevals[0] || {};
            return new RRule2(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);
          }
          function rrulestr(s, options) {
            if (options === void 0) {
              options = {};
            }
            return buildRule(s, rrulestr_initializeOptions(options));
          }
          function groomRruleOptions(val, dtstart, tzid) {
            return __assign(__assign({}, val), { dtstart, tzid });
          }
          function rrulestr_initializeOptions(options) {
            var invalid = [];
            var keys = Object.keys(options);
            var defaultKeys2 = Object.keys(rrulestr_DEFAULT_OPTIONS);
            keys.forEach(function(key) {
              if (!includes(defaultKeys2, key))
                invalid.push(key);
            });
            if (invalid.length) {
              throw new Error("Invalid options: " + invalid.join(", "));
            }
            return __assign(__assign({}, rrulestr_DEFAULT_OPTIONS), options);
          }
          function extractName(line) {
            if (line.indexOf(":") === -1) {
              return {
                name: "RRULE",
                value: line
              };
            }
            var _a = split(line, ":", 1), name = _a[0], value = _a[1];
            return {
              name,
              value
            };
          }
          function breakDownLine(line) {
            var _a = extractName(line), name = _a.name, value = _a.value;
            var parms = name.split(";");
            if (!parms)
              throw new Error("empty property name");
            return {
              name: parms[0].toUpperCase(),
              parms: parms.slice(1),
              value
            };
          }
          function splitIntoLines(s, unfold) {
            if (unfold === void 0) {
              unfold = false;
            }
            s = s && s.trim();
            if (!s)
              throw new Error("Invalid empty string");
            if (!unfold) {
              return s.split(/\s/);
            }
            var lines = s.split("\n");
            var i = 0;
            while (i < lines.length) {
              var line = lines[i] = lines[i].replace(/\s+$/g, "");
              if (!line) {
                lines.splice(i, 1);
              } else if (i > 0 && line[0] === " ") {
                lines[i - 1] += line.slice(1);
                lines.splice(i, 1);
              } else {
                i += 1;
              }
            }
            return lines;
          }
          function validateDateParm(parms) {
            parms.forEach(function(parm) {
              if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
                throw new Error("unsupported RDATE/EXDATE parm: " + parm);
              }
            });
          }
          function parseRDate(rdateval, parms) {
            validateDateParm(parms);
            return rdateval.split(",").map(function(datestr) {
              return untilStringToDate(datestr);
            });
          }
          ;
          function createGetterSetter(fieldName) {
            var _this = this;
            return function(field) {
              if (field !== void 0) {
                _this["_".concat(fieldName)] = field;
              }
              if (_this["_".concat(fieldName)] !== void 0) {
                return _this["_".concat(fieldName)];
              }
              for (var i = 0; i < _this._rrule.length; i++) {
                var field_1 = _this._rrule[i].origOptions[fieldName];
                if (field_1) {
                  return field_1;
                }
              }
            };
          }
          var RRuleSet2 = (
            /** @class */
            (function(_super) {
              __extends(RRuleSet3, _super);
              function RRuleSet3(noCache) {
                if (noCache === void 0) {
                  noCache = false;
                }
                var _this = _super.call(this, {}, noCache) || this;
                _this.dtstart = createGetterSetter.apply(_this, ["dtstart"]);
                _this.tzid = createGetterSetter.apply(_this, ["tzid"]);
                _this._rrule = [];
                _this._rdate = [];
                _this._exrule = [];
                _this._exdate = [];
                return _this;
              }
              RRuleSet3.prototype._iter = function(iterResult) {
                return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
              };
              RRuleSet3.prototype.rrule = function(rrule) {
                _addRule(rrule, this._rrule);
              };
              RRuleSet3.prototype.exrule = function(rrule) {
                _addRule(rrule, this._exrule);
              };
              RRuleSet3.prototype.rdate = function(date) {
                _addDate(date, this._rdate);
              };
              RRuleSet3.prototype.exdate = function(date) {
                _addDate(date, this._exdate);
              };
              RRuleSet3.prototype.rrules = function() {
                return this._rrule.map(function(e) {
                  return rrulestr(e.toString());
                });
              };
              RRuleSet3.prototype.exrules = function() {
                return this._exrule.map(function(e) {
                  return rrulestr(e.toString());
                });
              };
              RRuleSet3.prototype.rdates = function() {
                return this._rdate.map(function(e) {
                  return new Date(e.getTime());
                });
              };
              RRuleSet3.prototype.exdates = function() {
                return this._exdate.map(function(e) {
                  return new Date(e.getTime());
                });
              };
              RRuleSet3.prototype.valueOf = function() {
                var result = [];
                if (!this._rrule.length && this._dtstart) {
                  result = result.concat(optionsToString({ dtstart: this._dtstart }));
                }
                this._rrule.forEach(function(rrule) {
                  result = result.concat(rrule.toString().split("\n"));
                });
                this._exrule.forEach(function(exrule) {
                  result = result.concat(exrule.toString().split("\n").map(function(line) {
                    return line.replace(/^RRULE:/, "EXRULE:");
                  }).filter(function(line) {
                    return !/^DTSTART/.test(line);
                  }));
                });
                if (this._rdate.length) {
                  result.push(rdatesToString("RDATE", this._rdate, this.tzid()));
                }
                if (this._exdate.length) {
                  result.push(rdatesToString("EXDATE", this._exdate, this.tzid()));
                }
                return result;
              };
              RRuleSet3.prototype.toString = function() {
                return this.valueOf().join("\n");
              };
              RRuleSet3.prototype.clone = function() {
                var rrs = new RRuleSet3(!!this._cache);
                this._rrule.forEach(function(rule) {
                  return rrs.rrule(rule.clone());
                });
                this._exrule.forEach(function(rule) {
                  return rrs.exrule(rule.clone());
                });
                this._rdate.forEach(function(date) {
                  return rrs.rdate(new Date(date.getTime()));
                });
                this._exdate.forEach(function(date) {
                  return rrs.exdate(new Date(date.getTime()));
                });
                return rrs;
              };
              return RRuleSet3;
            })(RRule2)
          );
          function _addRule(rrule, collection) {
            if (!(rrule instanceof RRule2)) {
              throw new TypeError(String(rrule) + " is not RRule instance");
            }
            if (!includes(collection.map(String), String(rrule))) {
              collection.push(rrule);
            }
          }
          function _addDate(date, collection) {
            if (!(date instanceof Date)) {
              throw new TypeError(String(date) + " is not Date instance");
            }
            if (!includes(collection.map(Number), Number(date))) {
              collection.push(date);
              sort(collection);
            }
          }
          function rdatesToString(param, rdates, tzid) {
            var isUTC = !tzid || tzid.toUpperCase() === "UTC";
            var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
            var dateString = rdates.map(function(rdate) {
              return timeToUntilString(rdate.valueOf(), isUTC);
            }).join(",");
            return "".concat(header).concat(dateString);
          }
          ;
          return __webpack_exports__;
        })()
      );
    });
  }
});

// node_modules/node-ical/windowsZones.json
var require_windowsZones = __commonJS({
  "node_modules/node-ical/windowsZones.json"(exports, module2) {
    module2.exports = {
      "(GMT+10:00) Canberra, Melbourne, Sydney": { iana: ["Australia/Sydney"] },
      "(UTC) Casablanca": { iana: ["Africa/Casablanca"] },
      "(UTC) Coordinated Universal Time": { iana: ["Etc/UTC"] },
      "(UTC) Greenwich Mean Time: Dublin, Edinburgh, Lisbon, London": { iana: ["Europe/London"] },
      "(UTC) Monrovia, Reykjavik": { iana: ["Atlantic/Reykjavik"] },
      "(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna": { iana: ["Europe/Berlin"] },
      "(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague": { iana: ["Europe/Budapest"] },
      "(UTC+01:00) Brussels, Copenhagen, Madrid, Paris": { iana: ["Europe/Paris"] },
      "(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb": { iana: ["Europe/Warsaw"] },
      "(UTC+01:00) West Central Africa": { iana: ["Africa/Lagos"] },
      "(UTC+02:00) Amman": { iana: ["Asia/Amman"] },
      "(UTC+02:00) Athens, Bucharest, Istanbul": { iana: ["Europe/Bucharest"] },
      "(UTC+02:00) Beirut": { iana: ["Asia/Beirut"] },
      "(UTC+02:00) Cairo": { iana: ["Africa/Cairo"] },
      "(UTC+02:00) Harare, Pretoria": { iana: ["Africa/Johannesburg"] },
      "(UTC+02:00) Helsinki, Kiev, Riga, Sofia, Tallinn, Vilnius": { iana: ["Europe/Kiev"] },
      "(UTC+02:00) Jerusalem": { iana: ["Asia/Jerusalem"] },
      "(UTC+02:00) Minsk": { iana: ["Europe/Chisinau"] },
      "(UTC+02:00) Windhoek": { iana: ["Africa/Windhoek"] },
      "(UTC+03:00) Baghdad": { iana: ["Asia/Baghdad"] },
      "(UTC+03:00) Kuwait, Riyadh": { iana: ["Asia/Riyadh"] },
      "(UTC+03:00) Moscow, St. Petersburg, Volgograd": { iana: ["Europe/Moscow"] },
      "(UTC+03:00) Nairobi": { iana: ["Africa/Nairobi"] },
      "(UTC+03:00) Tbilisi": { iana: ["Asia/Tbilisi"] },
      "(UTC+03:30) Tehran": { iana: ["Asia/Tehran"] },
      "(UTC+04:00) Abu Dhabi, Muscat": { iana: ["Asia/Dubai"] },
      "(UTC+04:00) Baku": { iana: ["Asia/Baku"] },
      "(UTC+04:00) Baku, Tbilisi, Yerevan": { iana: ["Asia/Yerevan"] },
      "(UTC+04:00) Port Louis": { iana: ["Indian/Mauritius"] },
      "(UTC+04:00) Yerevan": { iana: ["Asia/Yerevan"] },
      "(UTC+04:30) Kabul": { iana: ["Asia/Kabul"] },
      "(UTC+05:00) Ekaterinburg": { iana: ["Asia/Yekaterinburg"] },
      "(UTC+05:00) Islamabad, Karachi": { iana: ["Asia/Karachi"] },
      "(UTC+05:00) Tashkent": { iana: ["Asia/Tashkent"] },
      "(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi": { iana: ["Asia/Calcutta"] },
      "(UTC+05:45) Kathmandu": { iana: ["Asia/Katmandu"] },
      "(UTC+06:00) Almaty, Novosibirsk": { iana: ["Asia/Novosibirsk"] },
      "(UTC+06:00) Astana, Dhaka": { iana: ["Asia/Bishkek"] },
      "(UTC+06:00) Sri Jayawardenepura": { iana: ["Asia/Colombo"] },
      "(UTC+06:30) Yangon (Rangoon)": { iana: ["Asia/Rangoon"] },
      "(UTC+07:00) Bangkok, Hanoi, Jakarta": { iana: ["Asia/Bangkok"] },
      "(UTC+07:00) Krasnoyarsk": { iana: ["Asia/Krasnoyarsk"] },
      "(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi": { iana: ["Asia/Shanghai"] },
      "(UTC+08:00) Irkutsk, Ulaanbaatar": { iana: ["Asia/Irkutsk"] },
      "(UTC+08:00) Kuala Lumpur, Singapore": { iana: ["Asia/Singapore"] },
      "(UTC+08:00) Perth": { iana: ["Australia/Perth"] },
      "(UTC+08:00) Taipei": { iana: ["Asia/Taipei"] },
      "(UTC+09:00) Osaka, Sapporo, Tokyo": { iana: ["Asia/Tokyo"] },
      "(UTC+09:00) Seoul": { iana: ["Asia/Seoul"] },
      "(UTC+09:00) Yakutsk": { iana: ["Asia/Yakutsk"] },
      "(UTC+09:30) Adelaide": { iana: ["Australia/Adelaide"] },
      "(UTC+09:30) Darwin": { iana: ["Australia/Darwin"] },
      "(UTC+10:00) Brisbane": { iana: ["Australia/Brisbane"] },
      "(UTC+10:00) Canberra, Melbourne, Sydney": { iana: ["Australia/Sydney"] },
      "(UTC+10:00) Guam, Port Moresby": { iana: ["Pacific/Port_Moresby"] },
      "(UTC+10:00) Hobart": { iana: ["Australia/Hobart"] },
      "(UTC+10:00) Vladivostok": { iana: ["Asia/Vladivostok"] },
      "(UTC+11:00) Magadan, Solomon Islands, New Caledonia": { iana: ["Pacific/Guadalcanal"] },
      "(UTC+12:00) Auckland, Wellington": { iana: ["Pacific/Auckland"] },
      "(UTC+12:00) Fiji, Kamchatka, Marshall Is.": { iana: ["Pacific/Fiji"] },
      "(UTC+12:00) Petropavlovsk-Kamchatsky": { iana: ["Asia/Kamchatka"] },
      "(UTC+13:00) Nuku'alofa": { iana: ["Pacific/Tongatapu"] },
      "(UTC-01:00) Azores": { iana: ["Atlantic/Azores"] },
      "(UTC-01:00) Cape Verde Islands": { iana: ["Atlantic/Cape_Verde"] },
      "(UTC-02:00) Mid-Atlantic": { iana: ["Etc/GMT+2"] },
      "(UTC-03:00) Brasilia": { iana: ["America/Sao_Paulo"] },
      "(UTC-03:00) Buenos Aires": { iana: ["America/Buenos_Aires"] },
      "(UTC-03:00) Georgetown": { iana: ["America/Cayenne"] },
      "(UTC-03:00) Greenland": { iana: ["America/Godthab"] },
      "(UTC-03:00) Montevideo": { iana: ["America/Montevideo"] },
      "(UTC-03:30) Newfoundland": { iana: ["America/St_Johns"] },
      "(UTC-04:00) Asuncion": { iana: ["America/Asuncion"] },
      "(UTC-04:00) Atlantic Time (Canada)": { iana: ["America/Halifax"] },
      "(UTC-04:00) Georgetown, La Paz, San Juan": { iana: ["America/La_Paz"] },
      "(UTC-04:00) Manaus": { iana: ["America/Cuiaba"] },
      "(UTC-04:00) Santiago": { iana: ["America/Santiago"] },
      "(UTC-04:30) Caracas": { iana: ["America/Caracas"] },
      "(UTC-05:00) Bogota, Lima, Quito": { iana: ["America/Bogota"] },
      "(UTC-05:00) Eastern Time (US & Canada)": { iana: ["America/New_York"] },
      "(UTC-05:00) Eastern Time (US and Canada)": { iana: ["America/New_York"] },
      "(UTC-05:00) Indiana (East)": { iana: ["America/Indianapolis"] },
      "(UTC-06:00) Central America": { iana: ["America/Guatemala"] },
      "(UTC-06:00) Central Time (US & Canada)": { iana: ["America/Chicago"] },
      "(UTC-06:00) Central Time (US and Canada)": { iana: ["America/Chicago"] },
      "(UTC-06:00) Guadalajara, Mexico City, Monterrey": { iana: ["America/Mexico_City"] },
      "(UTC-06:00) Guadalajara, Mexico City, Monterrey - New": { iana: ["America/Mexico_City"] },
      "(UTC-06:00) Saskatchewan": { iana: ["America/Regina"] },
      "(UTC-07:00) Arizona": { iana: ["America/Phoenix"] },
      "(UTC-07:00) Chihuahua, La Paz, Mazatlan": { iana: ["America/Mazatlan"] },
      "(UTC-07:00) Chihuahua, La Paz, Mazatlan - New": { iana: ["America/Mazatlan"] },
      "(UTC-07:00) Mountain Time (US & Canada)": { iana: ["America/Denver"] },
      "(UTC-07:00) Mountain Time (US and Canada)": { iana: ["America/Denver"] },
      "(UTC-08:00) Pacific Time (US & Canada); Tijuana": { iana: ["America/Los_Angeles"] },
      "(UTC-08:00) Pacific Time (US and Canada); Tijuana": { iana: ["America/Los_Angeles"] },
      "(UTC-08:00) Tijuana, Baja California": { iana: ["America/Tijuana"] },
      "(UTC-09:00) Alaska": { iana: ["America/Anchorage"] },
      "(UTC-10:00) Hawaii": { iana: ["Pacific/Honolulu"] },
      "(UTC-11:00) Midway Island, Samoa": { iana: ["Pacific/Apia"] },
      "(UTC-12:00) International Date Line West": { iana: ["Etc/GMT+12"] },
      "AUS Central Standard Time": { iana: ["Australia/Darwin"] },
      "AUS Eastern Standard Time": { iana: ["Australia/Sydney"] },
      "Afghanistan Standard Time": { iana: ["Asia/Kabul"] },
      "Alaskan Standard Time": { iana: ["America/Anchorage"] },
      "Aleutian Standard Time": { iana: ["America/Adak"] },
      "Altai Standard Time": { iana: ["Asia/Barnaul"] },
      "Arab Standard Time": { iana: ["Asia/Riyadh"] },
      "Arabian Standard Time": { iana: ["Asia/Dubai"] },
      "Arabic Standard Time": { iana: ["Asia/Baghdad"] },
      "Argentina Standard Time": { iana: ["America/Buenos_Aires"] },
      "Astrakhan Standard Time": { iana: ["Europe/Astrakhan"] },
      "Atlantic Standard Time": { iana: ["America/Halifax"] },
      "Aus Central W. Standard Time": { iana: ["Australia/Eucla"] },
      "Azerbaijan Standard Time": { iana: ["Asia/Baku"] },
      "Azores Standard Time": { iana: ["Atlantic/Azores"] },
      "Bahia Standard Time": { iana: ["America/Bahia"] },
      "Bangladesh Standard Time": { iana: ["Asia/Dhaka"] },
      "Belarus Standard Time": { iana: ["Europe/Minsk"] },
      "Bougainville Standard Time": { iana: ["Pacific/Bougainville"] },
      "Canada Central Standard Time": { iana: ["America/Regina"] },
      "Cape Verde Standard Time": { iana: ["Atlantic/Cape_Verde"] },
      "Caucasus Standard Time": { iana: ["Asia/Yerevan"] },
      "Cen. Australia Standard Time": { iana: ["Australia/Adelaide"] },
      "Central America Standard Time": { iana: ["America/Guatemala"] },
      "Central Asia Standard Time": { iana: ["Asia/Bishkek"] },
      "Central Brazilian Standard Time": { iana: ["America/Cuiaba"] },
      "Central Europe Standard Time": { iana: ["Europe/Budapest"] },
      "Central European Standard Time": { iana: ["Europe/Warsaw"] },
      "Central Pacific Standard Time": { iana: ["Pacific/Guadalcanal"] },
      "Central Standard Time": { iana: ["America/Chicago"] },
      "Central Standard Time (Mexico)": { iana: ["America/Mexico_City"] },
      "Chatham Islands Standard Time": { iana: ["Pacific/Chatham"] },
      "China Standard Time": { iana: ["Asia/Shanghai"] },
      "Cuba Standard Time": { iana: ["America/Havana"] },
      "Dateline Standard Time": { iana: ["Etc/GMT+12"] },
      "E. Africa Standard Time": { iana: ["Africa/Nairobi"] },
      "E. Australia Standard Time": { iana: ["Australia/Brisbane"] },
      "E. Europe Standard Time": { iana: ["Europe/Chisinau"] },
      "E. South America Standard Time": { iana: ["America/Sao_Paulo"] },
      "Easter Island Standard Time": { iana: ["Pacific/Easter"] },
      "Eastern Standard Time": { iana: ["America/New_York"] },
      "Eastern Standard Time (Mexico)": { iana: ["America/Cancun"] },
      "Egypt Standard Time": { iana: ["Africa/Cairo"] },
      "Ekaterinburg Standard Time": { iana: ["Asia/Yekaterinburg"] },
      "FLE Standard Time": { iana: ["Europe/Kiev"] },
      "Fiji Standard Time": { iana: ["Pacific/Fiji"] },
      "GMT Standard Time": { iana: ["Europe/London"] },
      "GTB Standard Time": { iana: ["Europe/Bucharest"] },
      "Georgian Standard Time": { iana: ["Asia/Tbilisi"] },
      "Greenland Standard Time": { iana: ["America/Godthab"] },
      "Greenwich Standard Time": { iana: ["Atlantic/Reykjavik"] },
      "Haiti Standard Time": { iana: ["America/Port-au-Prince"] },
      "Hawaiian Standard Time": { iana: ["Pacific/Honolulu"] },
      "India Standard Time": { iana: ["Asia/Calcutta"] },
      "Iran Standard Time": { iana: ["Asia/Tehran"] },
      "Israel Standard Time": { iana: ["Asia/Jerusalem"] },
      "Jordan Standard Time": { iana: ["Asia/Amman"] },
      "Kaliningrad Standard Time": { iana: ["Europe/Kaliningrad"] },
      "Korea Standard Time": { iana: ["Asia/Seoul"] },
      "Libya Standard Time": { iana: ["Africa/Tripoli"] },
      "Line Islands Standard Time": { iana: ["Pacific/Kiritimati"] },
      "Lord Howe Standard Time": { iana: ["Australia/Lord_Howe"] },
      "Magadan Standard Time": { iana: ["Asia/Magadan"] },
      "Magallanes Standard Time": { iana: ["America/Punta_Arenas"] },
      "Marquesas Standard Time": { iana: ["Pacific/Marquesas"] },
      "Mauritius Standard Time": { iana: ["Indian/Mauritius"] },
      "Middle East Standard Time": { iana: ["Asia/Beirut"] },
      "Montevideo Standard Time": { iana: ["America/Montevideo"] },
      "Morocco Standard Time": { iana: ["Africa/Casablanca"] },
      "Mountain Standard Time": { iana: ["America/Denver"] },
      "Mountain Standard Time (Mexico)": { iana: ["America/Mazatlan"] },
      "Myanmar Standard Time": { iana: ["Asia/Rangoon"] },
      "N. Central Asia Standard Time": { iana: ["Asia/Novosibirsk"] },
      "Namibia Standard Time": { iana: ["Africa/Windhoek"] },
      "Nepal Standard Time": { iana: ["Asia/Katmandu"] },
      "New Zealand Standard Time": { iana: ["Pacific/Auckland"] },
      "Newfoundland Standard Time": { iana: ["America/St_Johns"] },
      "Norfolk Standard Time": { iana: ["Pacific/Norfolk"] },
      "North Asia East Standard Time": { iana: ["Asia/Irkutsk"] },
      "North Asia Standard Time": { iana: ["Asia/Krasnoyarsk"] },
      "North Korea Standard Time": { iana: ["Asia/Pyongyang"] },
      "Omsk Standard Time": { iana: ["Asia/Omsk"] },
      "Pacific SA Standard Time": { iana: ["America/Santiago"] },
      "Pacific Standard Time": { iana: ["America/Los_Angeles"] },
      "Pacific Standard Time (Mexico)": { iana: ["America/Tijuana"] },
      "Pakistan Standard Time": { iana: ["Asia/Karachi"] },
      "Paraguay Standard Time": { iana: ["America/Asuncion"] },
      "Qyzylorda Standard Time": { iana: ["Asia/Qyzylorda"] },
      "Romance Standard Time": { iana: ["Europe/Paris"] },
      "Russia Time Zone 10": { iana: ["Asia/Srednekolymsk"] },
      "Russia Time Zone 11": { iana: ["Asia/Kamchatka"] },
      "Russia Time Zone 3": { iana: ["Europe/Samara"] },
      "Russian Standard Time": { iana: ["Europe/Moscow"] },
      "SA Eastern Standard Time": { iana: ["America/Cayenne"] },
      "SA Pacific Standard Time": { iana: ["America/Bogota"] },
      "SA Western Standard Time": { iana: ["America/La_Paz"] },
      "SE Asia Standard Time": { iana: ["Asia/Bangkok"] },
      "Saint Pierre Standard Time": { iana: ["America/Miquelon"] },
      "Sakhalin Standard Time": { iana: ["Asia/Sakhalin"] },
      "Samoa Standard Time": { iana: ["Pacific/Apia"] },
      "Sao Tome Standard Time": { iana: ["Africa/Sao_Tome"] },
      "Saratov Standard Time": { iana: ["Europe/Saratov"] },
      "Singapore Standard Time": { iana: ["Asia/Singapore"] },
      "South Africa Standard Time": { iana: ["Africa/Johannesburg"] },
      "South Sudan Standard Time": { iana: ["Africa/Juba"] },
      "Sri Lanka Standard Time": { iana: ["Asia/Colombo"] },
      "Sudan Standard Time": { iana: ["Africa/Khartoum"] },
      "Syria Standard Time": { iana: ["Asia/Damascus"] },
      "Taipei Standard Time": { iana: ["Asia/Taipei"] },
      "Tasmania Standard Time": { iana: ["Australia/Hobart"] },
      "Tocantins Standard Time": { iana: ["America/Araguaina"] },
      "Tokyo Standard Time": { iana: ["Asia/Tokyo"] },
      "Tomsk Standard Time": { iana: ["Asia/Tomsk"] },
      "Tonga Standard Time": { iana: ["Pacific/Tongatapu"] },
      "Transbaikal Standard Time": { iana: ["Asia/Chita"] },
      "Turkey Standard Time": { iana: ["Europe/Istanbul"] },
      "Turks And Caicos Standard Time": { iana: ["America/Grand_Turk"] },
      "US Eastern Standard Time": { iana: ["America/Indianapolis"] },
      "US Mountain Standard Time": { iana: ["America/Phoenix"] },
      UTC: { iana: ["Etc/UTC"] },
      "UTC+12": { iana: ["Etc/GMT-12"] },
      "UTC+13": { iana: ["Etc/GMT-13"] },
      "UTC-02": { iana: ["Etc/GMT+2"] },
      "UTC-08": { iana: ["Etc/GMT+8"] },
      "UTC-09": { iana: ["Etc/GMT+9"] },
      "UTC-11": { iana: ["Etc/GMT+11"] },
      "Ulaanbaatar Standard Time": { iana: ["Asia/Ulaanbaatar"] },
      "Venezuela Standard Time": { iana: ["America/Caracas"] },
      "Vladivostok Standard Time": { iana: ["Asia/Vladivostok"] },
      "Volgograd Standard Time": { iana: ["Europe/Volgograd"] },
      "W. Australia Standard Time": { iana: ["Australia/Perth"] },
      "W. Central Africa Standard Time": { iana: ["Africa/Lagos"] },
      "W. Europe Standard Time": { iana: ["Europe/Berlin"] },
      "W. Mongolia Standard Time": { iana: ["Asia/Hovd"] },
      "West Asia Standard Time": { iana: ["Asia/Tashkent"] },
      "West Bank Standard Time": { iana: ["Asia/Hebron"] },
      "West Pacific Standard Time": { iana: ["Pacific/Port_Moresby"] },
      "Yakutsk Standard Time": { iana: ["Asia/Yakutsk"] },
      "Yukon Standard Time": { iana: ["America/Whitehorse"] }
    };
  }
});

// node_modules/node-ical/tz-utils.js
var require_tz_utils = __commonJS({
  "node_modules/node-ical/tz-utils.js"(exports, module2) {
    var aliasMap = /* @__PURE__ */ new Map();
    var windowsZones = require_windowsZones();
    function normalizeWindowsLabel(label) {
      return String(label).replaceAll(/\s+/g, " ").trim().toLowerCase();
    }
    function buildWindowsLabelIndex(source) {
      const index = /* @__PURE__ */ new Map();
      const addVariant = (label, data) => {
        const normalized = normalizeWindowsLabel(label);
        if (!normalized || index.has(normalized)) {
          return;
        }
        index.set(normalized, data);
      };
      for (const [label, data] of Object.entries(source)) {
        addVariant(label, data);
        const withoutOffset = label.replace(/^\(utc[^)]*\)\s*/i, "").replace(/^\(gmt[^)]*\)\s*/i, "");
        if (withoutOffset !== label) {
          addVariant(withoutOffset, data);
          if (withoutOffset.includes(",")) {
            for (const segment of withoutOffset.split(",")) {
              addVariant(segment, data);
            }
          }
        }
      }
      return index;
    }
    var windowsLabelIndex = buildWindowsLabelIndex(windowsZones);
    function mapWindowsZone(label) {
      const exact = windowsZones[label];
      if (exact && Array.isArray(exact.iana) && exact.iana.length > 0) {
        return exact.iana[0];
      }
      const normalized = normalizeWindowsLabel(label);
      const indexed = windowsLabelIndex.get(normalized);
      if (indexed && Array.isArray(indexed.iana) && indexed.iana.length > 0) {
        return indexed.iana[0];
      }
      if (label.includes(",")) {
        for (const segment of label.split(",")) {
          const variant = windowsLabelIndex.get(normalizeWindowsLabel(segment));
          if (variant && Array.isArray(variant.iana) && variant.iana.length > 0) {
            return variant.iana[0];
          }
        }
      }
      return null;
    }
    function pad2(value) {
      return String(value).padStart(2, "0");
    }
    var dtfCache = /* @__PURE__ */ new Map();
    var validIanaCache = /* @__PURE__ */ new Map();
    function getFormatter(tz) {
      let formatter = dtfCache.get(tz);
      if (!formatter) {
        formatter = new Intl.DateTimeFormat("en-CA", {
          timeZone: tz,
          hour12: false,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        });
        dtfCache.set(tz, formatter);
      }
      return formatter;
    }
    function normalizeMidnightParts(date, formatter, parts) {
      if (!parts || typeof (formatter == null ? void 0 : formatter.formatToParts) !== "function") {
        return parts;
      }
      const next = new Date(date.getTime() + 1e3);
      const nextParts = formatter.formatToParts(next);
      for (const p of nextParts) {
        if (p.type === "year") {
          parts.year = Number(p.value);
        }
        if (p.type === "month") {
          parts.month = Number(p.value);
        }
        if (p.type === "day") {
          parts.day = Number(p.value);
        }
      }
      parts.hour = 0;
      parts.minute = 0;
      parts.second = 0;
      return parts;
    }
    function offsetLabelToMinutes(offset) {
      if (!offset) {
        return void 0;
      }
      const trimmed = String(offset).trim().replace(/^\(?(?:utc|gmt)\)?\s*/i, "").replace(/\)$/, "").trim();
      const match = trimmed.match(/^([+-])(\d{1,2})(?::?(\d{2}))?$/);
      if (!match) {
        return void 0;
      }
      const [, sign, hoursPart, minutesPart] = match;
      const hours = Number(hoursPart);
      const minutes = minutesPart ? Number(minutesPart) : 0;
      if (Number.isNaN(hours) || Number.isNaN(minutes)) {
        return void 0;
      }
      if (minutes >= 60) {
        return void 0;
      }
      if (hours > 14 || hours === 14 && minutes !== 0) {
        return void 0;
      }
      const total = hours * 60 + minutes;
      return sign === "-" ? -total : total;
    }
    function minutesToOffset(totalMinutes) {
      if (!Number.isFinite(totalMinutes)) {
        return void 0;
      }
      const sign = totalMinutes < 0 ? "-" : "+";
      const absolute = Math.abs(totalMinutes);
      const hours = Math.floor(absolute / 60);
      const minutes = absolute % 60;
      return `${sign}${pad2(hours)}:${pad2(minutes)}`;
    }
    function minutesToEtcZone(totalMinutes) {
      if (!Number.isFinite(totalMinutes)) {
        return void 0;
      }
      if (totalMinutes === 0) {
        return "Etc/GMT";
      }
      if (totalMinutes % 60 !== 0) {
        return void 0;
      }
      const hours = Math.abs(totalMinutes) / 60;
      const sign = totalMinutes > 0 ? "-" : "+";
      return `Etc/GMT${sign}${hours}`;
    }
    function ymdhmsToUtcMs(parts = {}) {
      const {
        year,
        month,
        day,
        hour = 0,
        minute = 0,
        second = 0
      } = parts;
      return Date.UTC(year, month - 1, day, hour, minute, second);
    }
    function convergeLocalInstant(initialUtcMs, targetParts, getLocalParts) {
      const targetUtc = ymdhmsToUtcMs(targetParts);
      let t = initialUtcMs;
      let estimate;
      let delta = 0;
      for (let i = 0; i < 3; i++) {
        estimate = new Date(t);
        const current = getLocalParts(estimate);
        delta = ymdhmsToUtcMs(current) - targetUtc;
        if (delta === 0) {
          return estimate;
        }
        t -= delta;
      }
      const finalCandidate = new Date(t);
      const finalDelta = ymdhmsToUtcMs(getLocalParts(finalCandidate)) - targetUtc;
      if (finalDelta >= 0) {
        return finalCandidate;
      }
      return estimate;
    }
    function resolveTZID(value) {
      if (typeof value !== "string" || value.length === 0) {
        return {
          original: void 0,
          iana: void 0,
          offset: void 0,
          offsetMinutes: void 0,
          etc: void 0
        };
      }
      let tz = value;
      if (tz === "tzone://Microsoft/Custom" || tz.startsWith("Customized Time Zone") || tz.startsWith("tzone://Microsoft/")) {
        tz = guessLocalZone();
      }
      tz = tz.replace(/^"(.*)"$/, "$1");
      const original = tz;
      if (tz && (tz.includes(" ") || tz.includes(","))) {
        const mapped = mapWindowsZone(tz);
        if (mapped) {
          tz = mapped;
        }
      }
      let offsetMinutes;
      if (tz && tz.startsWith("(")) {
        const offsetMatch = tz.match(/([+-]\d{1,2}:\d{2})/);
        if (offsetMatch) {
          offsetMinutes = offsetLabelToMinutes(offsetMatch[1]);
        }
        tz = null;
      }
      if (offsetMinutes === void 0 && tz) {
        const mins = offsetLabelToMinutes(tz);
        if (Number.isFinite(mins)) {
          offsetMinutes = mins;
          tz = null;
        }
      }
      const exact = findExactZoneMatch(tz);
      const iana = exact || (tz && isValidIana(tz) ? tz : void 0);
      const offset = minutesToOffset(offsetMinutes);
      const etc = minutesToEtcZone(offsetMinutes);
      return {
        original,
        iana,
        offset,
        offsetMinutes,
        etc
      };
    }
    function formatDateForRrule(date, tzInfo = {}) {
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
        return void 0;
      }
      if (tzInfo.iana && isValidIana(tzInfo.iana)) {
        const formatter = getFormatter(tzInfo.iana);
        const parts = formatter.formatToParts(date);
        const numericParts = /* @__PURE__ */ new Map([
          ["year", "year"],
          ["month", "month"],
          ["day", "day"],
          ["hour", "hour"],
          ["minute", "minute"],
          ["second", "second"]
        ]);
        const out = {};
        for (const part of parts) {
          const target = numericParts.get(part.type);
          if (!target) {
            continue;
          }
          out[target] = Number(part.value);
        }
        if (out.hour === 24) {
          normalizeMidnightParts(date, formatter, out);
        }
        if (out.year && out.month && out.day && out.hour !== void 0 && out.minute !== void 0 && out.second !== void 0) {
          return `${out.year}${pad2(out.month)}${pad2(out.day)}T${pad2(out.hour)}${pad2(out.minute)}${pad2(out.second)}`;
        }
      }
      if (Number.isFinite(tzInfo.offsetMinutes)) {
        const local = new Date(date.getTime() + tzInfo.offsetMinutes * 6e4);
        return `${local.getUTCFullYear()}${pad2(local.getUTCMonth() + 1)}${pad2(local.getUTCDate())}T${pad2(local.getUTCHours())}${pad2(local.getUTCMinutes())}${pad2(local.getUTCSeconds())}`;
      }
      return void 0;
    }
    function attachTz(date, tzid) {
      if (!date || !tzid) {
        return date;
      }
      const hasSameValue = date.tz === tzid;
      const isEnumerable = Object.prototype.propertyIsEnumerable.call(date, "tz");
      if (!hasSameValue || isEnumerable) {
        Object.defineProperty(date, "tz", {
          value: tzid,
          enumerable: false,
          configurable: true,
          writable: false
        });
      }
      return date;
    }
    function resolveZone(zone) {
      if (!zone) {
        return zone;
      }
      return aliasMap.get(zone) || zone;
    }
    function guessLocalZone() {
      return new Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    function getZoneNames() {
      return Intl.supportedValuesOf("timeZone");
    }
    function findExactZoneMatch(tz) {
      if (!tz) {
        return void 0;
      }
      const z = resolveZone(tz);
      return isValidIana(z) ? z : void 0;
    }
    function isValidIana(zone) {
      if (!zone) {
        return false;
      }
      const tz = resolveZone(zone);
      if (!tz) {
        return false;
      }
      if (validIanaCache.has(tz)) {
        return validIanaCache.get(tz);
      }
      try {
        new Intl.DateTimeFormat("en-US", { timeZone: tz }).format(/* @__PURE__ */ new Date(0));
        validIanaCache.set(tz, true);
        return true;
      } catch (e) {
        validIanaCache.set(tz, false);
        return false;
      }
    }
    function parseDateTimeInZone(yyyymmddThhmmss, zone) {
      const s = String(yyyymmddThhmmss);
      let m = s.match(/^(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2})(?::(\d{2}))?$/);
      let fields;
      if (m) {
        fields = {
          year: Number(m[1]),
          month: Number(m[2]),
          day: Number(m[3]),
          hour: Number(m[4]),
          minute: Number(m[5]),
          second: Number(m[6] || 0)
        };
      } else {
        m = s.match(/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})?$/);
        if (m) {
          fields = {
            year: Number(m[1]),
            month: Number(m[2]),
            day: Number(m[3]),
            hour: Number(m[4]),
            minute: Number(m[5]),
            second: Number(m[6] || 0)
          };
        }
      }
      if (!fields) {
        return void 0;
      }
      const tz = resolveZone(zone);
      if (!isValidIana(tz)) {
        return void 0;
      }
      const t = Date.UTC(fields.year, fields.month - 1, fields.day, fields.hour, fields.minute, fields.second);
      const getLocalParts = (date) => {
        const df = getFormatter(tz);
        const parts = df.formatToParts(date);
        const out = {};
        for (const p of parts) {
          if (p.type === "year") {
            out.year = Number(p.value);
          }
          if (p.type === "month") {
            out.month = Number(p.value);
          }
          if (p.type === "day") {
            out.day = Number(p.value);
          }
          if (p.type === "hour") {
            out.hour = Number(p.value);
          }
          if (p.type === "minute") {
            out.minute = Number(p.value);
          }
          if (p.type === "second") {
            out.second = Number(p.value);
          }
        }
        if (Object.hasOwn(out, "hour") && out.hour === 24) {
          normalizeMidnightParts(date, df, out);
        }
        return out;
      };
      const converged = convergeLocalInstant(t, fields, getLocalParts);
      return attachTz(converged, zone);
    }
    function parseWithOffset(yyyymmddThhmmss, offset) {
      const s = String(yyyymmddThhmmss);
      let m = s.match(/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})?$/);
      m || (m = s.match(/^(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2})(?::(\d{2}))?$/));
      if (!m) {
        return void 0;
      }
      const year = Number(m[1]);
      const month = Number(m[2]);
      const day = Number(m[3]);
      const hour = Number(m[4]);
      const minute = Number(m[5]);
      const second = Number(m[6] || 0);
      const totalMinutes = offsetLabelToMinutes(offset);
      if (!Number.isFinite(totalMinutes)) {
        throw new TypeError("Invalid offset string: " + offset);
      }
      const utcMs = Date.UTC(year, month - 1, day, hour, minute, second) - totalMinutes * 6e4;
      const normalizedOffset = minutesToOffset(totalMinutes);
      return attachTz(new Date(utcMs), normalizedOffset);
    }
    function utcAdd(date, amount, unit) {
      if (!(date instanceof Date)) {
        return void 0;
      }
      const msPer = {
        weeks: 7 * 24 * 60 * 60 * 1e3,
        days: 24 * 60 * 60 * 1e3,
        hours: 60 * 60 * 1e3,
        minutes: 60 * 1e3,
        seconds: 1e3
      };
      const factor = msPer[unit];
      if (!factor) {
        throw new Error("Unsupported unit: " + unit);
      }
      return new Date(date.getTime() + amount * factor);
    }
    function linkAlias(arg1, arg2) {
      if (arg2 === void 0) {
        const [a, b] = String(arg1).split("|");
        if (a && b) {
          aliasMap.set(a, b);
        }
        return;
      }
      aliasMap.set(String(arg1), String(arg2));
    }
    module2.exports = {
      guessLocalZone,
      getZoneNames,
      findExactZoneMatch,
      isValidIana,
      parseDateTimeInZone,
      parseWithOffset,
      utcAdd,
      linkAlias,
      resolveTZID,
      formatDateForRrule,
      attachTz,
      isUtcTimezone
    };
    module2.exports.__test__ = {
      normalizeMidnightParts,
      isUtcTimezone
    };
    function isUtcTimezone(tz) {
      if (!tz) {
        return false;
      }
      const tzLower = tz.toLowerCase();
      return tzLower === "etc/utc" || tzLower === "utc" || tzLower === "etc/gmt";
    }
  }
});

// node_modules/node-ical/ical.js
var require_ical = __commonJS({
  "node_modules/node-ical/ical.js"(exports, module2) {
    var { randomUUID } = require("node:crypto");
    var rrule = require_rrule().RRule;
    var tzUtil = require_tz_utils();
    var text = function(t = "") {
      return t.replaceAll(String.raw`\,`, ",").replaceAll(String.raw`\;`, ";").replaceAll(/\\[nN]/g, "\n").replaceAll("\\\\", "\\").replace(/^"(.*)"$/, "$1");
    };
    var parseValue = function(value) {
      if (value === "TRUE") {
        return true;
      }
      if (value === "FALSE") {
        return false;
      }
      const number = Number(value);
      if (!Number.isNaN(number)) {
        return number;
      }
      value = value.replace(/^"(.*)"$/, "$1");
      return value;
    };
    var parseParameters = function(p) {
      const out = {};
      for (const element of p) {
        if (element.includes("=")) {
          const segs = element.split("=");
          out[segs[0]] = parseValue(segs.slice(1).join("="));
        }
      }
      return out;
    };
    var storeValueParameter = function(name) {
      return function(value, curr) {
        const current = curr[name];
        if (Array.isArray(current)) {
          current.push(value);
          return curr;
        }
        curr[name] = current === void 0 ? value : [current, value];
        return curr;
      };
    };
    var storeParameter = function(name) {
      return function(value, parameters, curr) {
        const data = parameters && parameters.length > 0 && !(parameters.length === 1 && (parameters[0] === "CHARSET=utf-8" || parameters[0] === "VALUE=TEXT")) ? { params: parseParameters(parameters), val: text(value) } : text(value);
        return storeValueParameter(name)(data, curr);
      };
    };
    var addTZ = function(dt, parameters) {
      if (!dt) {
        return dt;
      }
      const p = parseParameters(parameters);
      if (parameters && p && p.TZID !== void 0) {
        let tzid = p.TZID.toString();
        tzid = tzid.replace(/^"(.*)"$/, "$1");
        return tzUtil.attachTz(dt, tzid);
      }
      if (dt.tz) {
        return tzUtil.attachTz(dt, dt.tz);
      }
      return dt;
    };
    function isDateOnly(value, parameters) {
      const dateOnly = parameters && parameters.includes("VALUE=DATE") && !parameters.includes("VALUE=DATE-TIME") || /^\d{8}$/.test(value) === true;
      return dateOnly;
    }
    var typeParameter = function(name) {
      return function(value, parameters, curr) {
        const returnValue = isDateOnly(value, parameters) ? "date" : "date-time";
        return storeValueParameter(name)(returnValue, curr);
      };
    };
    var dateParameter = function(name) {
      return function(value, parameters, curr, stack) {
        const pi = parameters.indexOf("TZID=tzone");
        if (pi !== -1) {
          parameters[pi] = parameters[pi] + ":" + value.split(":")[0];
          value = value.split(":")[1];
        }
        let newDate = text(value);
        if (isDateOnly(value, parameters)) {
          const comps2 = /^(\d{4})(\d{2})(\d{2}).*$/.exec(value);
          if (comps2 !== null) {
            newDate = new Date(comps2[1], Number.parseInt(comps2[2], 10) - 1, comps2[3]);
            newDate.dateOnly = true;
            return storeValueParameter(name)(newDate, curr);
          }
        }
        const comps = /^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(Z)?$/.exec(value);
        if (comps !== null) {
          const year = Number.parseInt(comps[1], 10);
          const monthIndex = Number.parseInt(comps[2], 10) - 1;
          const day = Number.parseInt(comps[3], 10);
          const hour = Number.parseInt(comps[4], 10);
          const minute = Number.parseInt(comps[5], 10);
          const second = Number.parseInt(comps[6], 10);
          if (comps[7] === "Z") {
            newDate = new Date(Date.UTC(year, monthIndex, day, hour, minute, second));
            tzUtil.attachTz(newDate, "Etc/UTC");
          } else {
            const fallbackWithStackTimezone = () => {
              const stackItemWithTimeZone = (stack || []).find((item) => Object.values(item).find((subItem) => subItem.type === "VTIMEZONE")) || {};
              const vTimezone = Object.values(stackItemWithTimeZone).find(({ type }) => type === "VTIMEZONE");
              const normalizedTzId = vTimezone ? Array.isArray(vTimezone.tzid) ? vTimezone.tzid.at(-1) : vTimezone.tzid : null;
              if (!normalizedTzId) {
                return new Date(year, monthIndex, day, hour, minute, second);
              }
              const tzInfo = tzUtil.resolveTZID(normalizedTzId);
              const offsetString = typeof tzInfo.offset === "string" ? tzInfo.offset : void 0;
              if (offsetString) {
                return tzUtil.parseWithOffset(value, offsetString);
              }
              if (tzInfo.iana) {
                return tzUtil.parseDateTimeInZone(value, tzInfo.iana);
              }
              return new Date(year, monthIndex, day, hour, minute, second);
            };
            if (parameters) {
              const parameterMap = parseParameters(parameters);
              let tz = parameterMap.TZID;
              const findTZIDIndex = () => {
                if (!Array.isArray(parameters)) {
                  return -1;
                }
                return parameters.findIndex((parameter) => typeof parameter === "string" && parameter.toUpperCase().startsWith("TZID="));
              };
              let tzParameterIndex = findTZIDIndex();
              const setTZIDParameter = (newTZID) => {
                if (!Array.isArray(parameters)) {
                  return;
                }
                const normalized = "TZID=" + newTZID;
                if (tzParameterIndex >= 0) {
                  parameters[tzParameterIndex] = normalized;
                } else {
                  parameters.push(normalized);
                  tzParameterIndex = parameters.length - 1;
                }
              };
              if (tz) {
                tz = tz.toString().replace(/^"(.*)"$/, "$1");
                if (tz === "tzone://Microsoft/Custom" || tz === "(no TZ description)" || tz.startsWith("Customized Time Zone") || tz.startsWith("tzone://Microsoft/")) {
                  tz = tzUtil.guessLocalZone();
                }
                const tzInfo = tzUtil.resolveTZID(tz);
                const resolvedTZID = tzInfo.iana || tzInfo.original || tz;
                setTZIDParameter(resolvedTZID);
                const offsetString = typeof tzInfo.offset === "string" ? tzInfo.offset : void 0;
                if (offsetString) {
                  newDate = tzUtil.parseWithOffset(value, offsetString);
                } else if (tzInfo.iana) {
                  newDate = tzUtil.parseDateTimeInZone(value, tzInfo.iana);
                } else {
                  newDate = new Date(year, monthIndex, day, hour, minute, second);
                }
                newDate = addTZ(newDate, parameters);
              } else {
                newDate = fallbackWithStackTimezone();
              }
            } else {
              newDate = fallbackWithStackTimezone();
            }
          }
        }
        return storeValueParameter(name)(newDate, curr);
      };
    };
    var geoParameter = function(name) {
      return function(value, parameters, curr) {
        storeParameter(value, parameters, curr);
        const parts = value.split(";");
        curr[name] = { lat: Number(parts[0]), lon: Number(parts[1]) };
        return curr;
      };
    };
    var categoriesParameter = function(name) {
      return function(value, parameters, curr) {
        storeParameter(value, parameters, curr);
        if (curr[name] === void 0) {
          curr[name] = value ? value.split(",").map((s) => s.trim()) : [];
        } else if (value) {
          curr[name] = curr[name].concat(value.split(",").map((s) => s.trim()));
        }
        return curr;
      };
    };
    var exdateParameter = function(name) {
      return function(value, parameters, curr) {
        curr[name] || (curr[name] = []);
        const dates = value ? value.split(",").map((s) => s.trim()) : [];
        for (const entry of dates) {
          const exdate = [];
          dateParameter(name)(entry, parameters, exdate);
          if (exdate[name]) {
            if (typeof exdate[name].toISOString === "function") {
              curr[name][exdate[name].toISOString().slice(0, 10)] = exdate[name];
            } else {
              throw new TypeError("No toISOString function in exdate[name] = " + exdate[name]);
            }
          }
        }
        return curr;
      };
    };
    var recurrenceParameter = function(name) {
      return dateParameter(name);
    };
    var addFBType = function(fb, parameters) {
      const p = parseParameters(parameters);
      if (parameters && p) {
        fb.type = p.FBTYPE || "BUSY";
      }
      return fb;
    };
    var freebusyParameter = function(name) {
      return function(value, parameters, curr) {
        const fb = addFBType({}, parameters);
        curr[name] || (curr[name] = []);
        curr[name].push(fb);
        storeParameter(value, parameters, fb);
        const parts = value.split("/");
        for (const [index, name2] of ["start", "end"].entries()) {
          dateParameter(name2)(parts[index], parameters, fb);
        }
        return curr;
      };
    };
    module2.exports = {
      objectHandlers: {
        BEGIN(component, parameters, curr, stack) {
          stack.push(curr);
          return { type: component, params: parameters };
        },
        END(value, parameters, curr, stack) {
          const originalEnd = function(component, parameters_, curr2, stack2) {
            var _a;
            if (component === "VCALENDAR") {
              let key;
              let object;
              const highLevel = {};
              for (key in curr2) {
                if (!Object.hasOwn(curr2, key)) {
                  continue;
                }
                object = curr2[key];
                if (typeof object === "string") {
                  highLevel[key] = object;
                  delete curr2[key];
                }
              }
              if (highLevel.type) {
                curr2[highLevel.type.toLowerCase()] = highLevel;
              }
              return curr2;
            }
            const par = stack2.pop();
            if (!curr2.end) {
              curr2.end = curr2.datetype === "date-time" ? new Date(curr2.start) : tzUtil.utcAdd(curr2.start, 1, "days");
              if (curr2.duration !== void 0) {
                const durationUnits = {
                  W: "weeks",
                  D: "days",
                  H: "hours",
                  M: "minutes",
                  S: "seconds"
                };
                const duration = curr2.duration.match(/-?\d{1,10}[WDHMS]/g);
                if (!duration || duration.length === 0) {
                  throw new Error("Invalid DURATION format: " + curr2.duration);
                }
                let newEnd = curr2.start;
                const indicator = curr2.duration.startsWith("-") ? -1 : 1;
                for (const r of duration) {
                  const unit = r.slice(-1);
                  if (!durationUnits[unit]) {
                    throw new Error(`Invalid duration unit: ${unit}`);
                  }
                  newEnd = tzUtil.utcAdd(newEnd, Number.parseInt(r, 10) * indicator, durationUnits[r.toString().slice(-1)]);
                }
                curr2.end = new Date(newEnd);
              }
            }
            if (curr2.uid) {
              if (par[curr2.uid] === void 0) {
                par[curr2.uid] = curr2;
                if (par.method) {
                  par[curr2.uid].method = par.method;
                }
              } else if (curr2.recurrenceid === void 0) {
                let key;
                for (key in curr2) {
                  if (key !== null) {
                    par[curr2.uid][key] = curr2[key];
                  }
                }
              }
              if (curr2.recurrenceid !== void 0) {
                const recurrenceObject = {};
                let key;
                for (key in curr2) {
                  if (key !== null) {
                    recurrenceObject[key] = curr2[key];
                  }
                }
                if (recurrenceObject.recurrences !== void 0) {
                  delete recurrenceObject.recurrences;
                }
                if (par[curr2.uid].recurrences === void 0) {
                  par[curr2.uid].recurrences = {};
                }
                if (typeof curr2.recurrenceid.toISOString === "function") {
                  par[curr2.uid].recurrences[curr2.recurrenceid.toISOString().slice(0, 10)] = recurrenceObject;
                } else {
                  throw new TypeError("No toISOString function in curr.recurrenceid =" + curr2.recurrenceid);
                }
              }
              if (curr2.uid !== "__proto__" && par[curr2.uid].rrule !== void 0 && par[curr2.uid].recurrenceid !== void 0) {
                delete par[curr2.uid].recurrenceid;
              }
            } else if (component === "VALARM" && (par.type === "VEVENT" || par.type === "VTODO")) {
              (_a = par.alarms) != null ? _a : par.alarms = [];
              par.alarms.push(curr2);
            } else {
              const id = randomUUID();
              par[id] = curr2;
              if (par.method) {
                par[id].method = par.method;
              }
            }
            return par;
          };
          if ((value === "VEVENT" || value === "VTODO" || value === "VJOURNAL") && curr.rrule) {
            let rule = curr.rrule.replace("RRULE:", "");
            rule = rule.slice(rule.lastIndexOf("FREQ="));
            if (rule.includes("DTSTART") === false) {
              if (curr.datetype === "date") {
                const originalStart = curr.start;
                const offset = originalStart.getTimezoneOffset();
                let nextStart;
                if (offset < 0) {
                  nextStart = new Date(originalStart.getTime() + Math.abs(offset) * 6e4);
                } else {
                  nextStart = new Date(
                    originalStart.getFullYear(),
                    originalStart.getMonth(),
                    originalStart.getDate(),
                    0,
                    0,
                    0,
                    0
                  );
                }
                curr.start = nextStart;
                if (originalStart && originalStart.tz) {
                  tzUtil.attachTz(curr.start, originalStart == null ? void 0 : originalStart.tz);
                }
                if (originalStart && originalStart.dateOnly === true) {
                  curr.start.dateOnly = true;
                }
              }
              if (curr.start && typeof curr.start.toISOString === "function") {
                try {
                  const isUtc = tzUtil.isUtcTimezone(curr.start.tz);
                  if (curr.start.tz && !isUtc) {
                    const tzInfo = tzUtil.resolveTZID(curr.start.tz);
                    const localStamp = tzUtil.formatDateForRrule(curr.start, tzInfo);
                    const tzidLabel = tzInfo.iana || tzInfo.etc || tzInfo.original;
                    if (localStamp && tzidLabel) {
                      rule += `;DTSTART;TZID=${tzidLabel}:${localStamp}`;
                    } else if (localStamp) {
                      rule += `;DTSTART=${localStamp}`;
                    } else {
                      rule += `;DTSTART=${curr.start.toISOString().replaceAll(/[-:]/g, "")}`;
                    }
                  } else {
                    rule += `;DTSTART=${curr.start.toISOString().replaceAll(/[-:]/g, "")}`;
                  }
                  rule = rule.replace(/\.\d{3}/, "");
                } catch (error) {
                  throw new Error("ERROR when trying to convert to ISOString " + error);
                }
              } else {
                throw new Error("No toISOString function in curr.start " + curr.start);
              }
            }
            try {
              curr.rrule = rrule.fromString(rule);
            } catch (error) {
              throw error;
            }
          }
          return originalEnd.call(this, value, parameters, curr, stack);
        },
        SUMMARY: storeParameter("summary"),
        DESCRIPTION: storeParameter("description"),
        URL: storeParameter("url"),
        UID: storeParameter("uid"),
        LOCATION: storeParameter("location"),
        DTSTART(value, parameters, curr, stack, line) {
          if (curr.start === void 0) {
            curr = dateParameter("start")(value, parameters, curr, stack);
            return typeParameter("datetype")(value, parameters, curr);
          }
          throw new Error("duplicate DTSTART encountered, line=" + line);
        },
        DTEND(value, parameters, curr, stack, line) {
          if (curr.end === void 0) {
            return dateParameter("end")(value, parameters, curr, stack);
          }
          throw new Error("duplicate DTEND encountered, line=" + line);
        },
        EXDATE: exdateParameter("exdate"),
        " CLASS": storeParameter("class"),
        // Should there be a space in this property?
        TRANSP: storeParameter("transparency"),
        GEO: geoParameter("geo"),
        "PERCENT-COMPLETE": storeParameter("completion"),
        COMPLETED: dateParameter("completed"),
        CATEGORIES: categoriesParameter("categories"),
        FREEBUSY: freebusyParameter("freebusy"),
        DTSTAMP: dateParameter("dtstamp"),
        CREATED: dateParameter("created"),
        "LAST-MODIFIED": dateParameter("lastmodified"),
        "RECURRENCE-ID": recurrenceParameter("recurrenceid"),
        RRULE(value, parameters, curr, stack, line) {
          curr.rrule = line;
          return curr;
        }
      },
      handleObject(name, value, parameters, ctx, stack, line) {
        if (this.objectHandlers[name]) {
          return this.objectHandlers[name](value, parameters, ctx, stack, line);
        }
        if (/X-[\w-]+/.test(name) && stack.length > 0) {
          name = name.slice(2);
          return storeParameter(name)(value, parameters, ctx, stack, line);
        }
        return storeParameter(name.toLowerCase())(value, parameters, ctx);
      },
      parseLines(lines, limit, ctx, stack, lastIndex, cb) {
        if (!cb && typeof ctx === "function") {
          cb = ctx;
          ctx = void 0;
        }
        ctx || (ctx = {});
        stack || (stack = []);
        let limitCounter = 0;
        let i = lastIndex || 0;
        for (let ii = lines.length; i < ii; i++) {
          let l = lines[i];
          while (lines[i + 1] && /[ \t]/.test(lines[i + 1][0])) {
            l += lines[i + 1].slice(1);
            i++;
          }
          if (l.includes("TZID=") && !l.includes('"(')) {
            l = l.replaceAll('"', "");
          }
          const exp = /^([\w\d-]+)((?:;[\w\d-]+=(?:(?:"[^"]*")|[^":;]+))*):(.*)$/;
          let kv = l.match(exp);
          if (kv === null) {
            continue;
          }
          kv = kv.slice(1);
          const value = kv.at(-1);
          const name = kv[0];
          const parameters = kv[1] ? kv[1].split(";").slice(1) : [];
          ctx = this.handleObject(name, value, parameters, ctx, stack, l) || {};
          if (++limitCounter > limit) {
            break;
          }
        }
        if (i >= lines.length) {
          delete ctx.type;
          delete ctx.params;
        }
        if (cb) {
          if (i < lines.length) {
            setImmediate(() => {
              this.parseLines(lines, limit, ctx, stack, i + 1, cb);
            });
          } else {
            setImmediate(() => {
              cb(null, ctx);
            });
          }
        } else {
          return ctx;
        }
      },
      parseICS(string, cb) {
        const lines = string.split(/\r?\n/);
        let ctx;
        if (cb) {
          this.parseLines(lines, 2e3, cb);
        } else {
          ctx = this.parseLines(lines, lines.length);
          return ctx;
        }
      }
    };
  }
});

// node_modules/node-ical/node-ical.js
var require_node_ical = __commonJS({
  "node_modules/node-ical/node-ical.js"(exports, module2) {
    var fs = require("node:fs");
    var ical2 = require_ical();
    function promiseCallback(fn, cb) {
      const promise = new Promise(fn);
      if (!cb) {
        return promise;
      }
      promise.then((returnValue) => {
        cb(null, returnValue);
      }).catch((error) => {
        cb(error, null);
      });
    }
    var sync2 = {};
    var async = {};
    var autodetect = {};
    async.fromURL = function(url, options, cb) {
      if (typeof options === "function" && cb === void 0) {
        cb = options;
        options = void 0;
      }
      return promiseCallback((resolve, reject) => {
        const fetchOptions = options && typeof options === "object" ? { ...options } : {};
        fetch(url, fetchOptions).then((response) => {
          if (!response.ok) {
            throw new Error(`${response.status} ${response.statusText}`);
          }
          return response.text();
        }).then((data) => {
          ical2.parseICS(data, (error, ics) => {
            if (error) {
              reject(error);
              return;
            }
            resolve(ics);
          });
        }).catch((error) => {
          reject(error);
        });
      }, cb);
    };
    async.parseFile = function(filename, cb) {
      return promiseCallback((resolve, reject) => {
        fs.readFile(filename, "utf8", (error, data) => {
          if (error) {
            reject(error);
            return;
          }
          ical2.parseICS(data, (error2, ics) => {
            if (error2) {
              reject(error2);
              return;
            }
            resolve(ics);
          });
        });
      }, cb);
    };
    async.parseICS = function(data, cb) {
      return promiseCallback((resolve, reject) => {
        ical2.parseICS(data, (error, ics) => {
          if (error) {
            reject(error);
            return;
          }
          resolve(ics);
        });
      }, cb);
    };
    sync2.parseFile = function(filename) {
      const data = fs.readFileSync(filename, "utf8");
      return ical2.parseICS(data);
    };
    sync2.parseICS = function(data) {
      return ical2.parseICS(data);
    };
    autodetect.parseFile = function(filename, cb) {
      if (!cb) {
        return sync2.parseFile(filename);
      }
      async.parseFile(filename, cb);
    };
    autodetect.parseICS = function(data, cb) {
      if (!cb) {
        return sync2.parseICS(data);
      }
      async.parseICS(data, cb);
    };
    module2.exports = {
      // Autodetect
      fromURL: async.fromURL,
      parseFile: autodetect.parseFile,
      parseICS: autodetect.parseICS,
      // Sync
      sync: sync2,
      // Async
      async,
      // Other backwards compat things
      objectHandlers: ical2.objectHandlers,
      handleObject: ical2.handleObject,
      parseLines: ical2.parseLines
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CalendarEventSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  ignoredEventTitles: [],
  eventFutureHourLimit: 4,
  eventRecentHourLimit: 2,
  selectablePastDays: 1,
  selectableFutureDays: 3
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Calendar ICS URL").setDesc("The secret URL where we can find your calendar events.").addText(
      (text) => text.setPlaceholder("Enter your ICS URL").setValue(this.plugin.settings.calendarICSUrl || "").onChange(async (value) => {
        this.plugin.settings.calendarICSUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Optional").setHeading();
    new import_obsidian.Setting(containerEl).setName("Calendar owner email").setDesc(
      "The email address of the calendar owner. This is used to filter out events that you've declined."
    ).addText(
      (text) => text.setPlaceholder("Enter your email address").setValue(this.plugin.settings.calendarOwnerEmail || "").onChange(async (value) => {
        this.plugin.settings.calendarOwnerEmail = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Ignored event titles").setDesc(
      "Events with these titles will be ignored when syncing with notes. Put each event name on a new line."
    ).addTextArea(
      (text) => {
        var _a;
        return text.setPlaceholder("Enter event titles to ignore").setValue(((_a = this.plugin.settings.ignoredEventTitles) == null ? void 0 : _a.join("\n")) || "").onChange(async (value) => {
          this.plugin.settings.ignoredEventTitles = value.split("\n").filter((title) => title !== "");
          await this.plugin.saveSettings();
        });
      }
    );
    this.addNumberSetting(
      "Quick sync - Past limit (hours)",
      "The number of hours in the past to consider an event as 'recent'.",
      "eventRecentHourLimit"
    );
    this.addNumberSetting(
      "Quick sync - Future limit (hours)",
      "The number of hours in the future to consider an event as 'upcoming'.",
      "eventFutureHourLimit"
    );
    this.addNumberSetting(
      "Select modal - Past limit (days)",
      "How many days in the past to show events in the selection modal.",
      "selectablePastDays"
    );
    this.addNumberSetting(
      "Select modal - Future limit (days)",
      "How many days in the future to show events in the selection modal.",
      "selectableFutureDays"
    );
  }
  addNumberSetting(name, desc, key) {
    new import_obsidian.Setting(this.containerEl).setName(name).setDesc(desc).addText(
      (text) => text.setValue(String(this.plugin.settings[key])).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        this.plugin.settings[key] = parsed || DEFAULT_SETTINGS[key];
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/interface.ts
var import_obsidian2 = require("obsidian");
var EventChoiceModal = class extends import_obsidian2.Modal {
  constructor(app, eventChoices, onChoose) {
    super(app);
    this.eventChoices = eventChoices.sort(
      (a, b) => a.start.getTime() - b.start.getTime()
    );
    this.onChoose = onChoose;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select an Event" });
    const eventList = contentEl.createEl("div", { cls: "event-list" });
    this.eventChoices.forEach((event) => {
      const eventEl = eventList.createEl("div", { cls: "event-choice" });
      const eventInfo = eventEl.createEl("div", { cls: "event-info" });
      eventInfo.createEl("div", {
        cls: "event-title",
        text: event.summary
      });
      const eventDetails = eventInfo.createEl("div", {
        cls: "event-details"
      });
      eventDetails.createEl("span", {
        cls: "event-date",
        text: event.start.toLocaleDateString("en-US", {
          weekday: "short",
          month: "short",
          day: "numeric"
        })
      });
      eventDetails.createEl("span", {
        cls: "event-time",
        text: event.start.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true
        })
      });
      eventDetails.createEl("span", {
        cls: "event-duration",
        text: this.formatDuration(event)
      });
      const selectButton = eventEl.createEl("button", { text: "Select" });
      selectButton.addEventListener("click", async () => {
        try {
          await this.onChoose(event);
          this.close();
        } catch (error) {
          new import_obsidian2.Notice(
            `Failed to sync event: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        }
      });
    });
  }
  formatDuration(event) {
    const durationMs = event.end.getTime() - event.start.getTime();
    const hours = Math.floor(durationMs / (1e3 * 60 * 60));
    const minutes = Math.floor(durationMs % (1e3 * 60 * 60) / (1e3 * 60));
    if (hours > 0 && minutes > 0) {
      return `${hours}h ${minutes}m`;
    } else if (hours > 0) {
      return `${hours}h`;
    } else {
      return `${minutes}m`;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/calendar.ts
var ical = __toESM(require_node_ical());
var import_rrule = __toESM(require_rrule());
var import_obsidian3 = require("obsidian");
var MS_PER_HOUR = 60 * 60 * 1e3;
var MS_PER_DAY = 24 * MS_PER_HOUR;
var FETCH_TIMEOUT_MS = 1e4;
var CalendarEvent = class {
  constructor(event, settings) {
    this.event = event;
    this.settings = settings;
  }
  get summary() {
    return this.event.summary;
  }
  get start() {
    return this.event.start;
  }
  get end() {
    return this.event.end;
  }
  get attendees() {
    const DEFAULT_ATTENDEE = {
      params: {
        CN: "Not visible for this event from ICS. Check your URL options."
      },
      val: "no-attendees"
    };
    const possibleAttendeeProperties = [
      this.event.attendee,
      this.event.attendees,
      this.event.ATTENDEE,
      this.event.attendeeList
    ];
    const attendees = possibleAttendeeProperties.find(
      (prop) => prop !== void 0
    );
    if (!attendees) {
      return [DEFAULT_ATTENDEE];
    }
    return Array.isArray(attendees) ? attendees : [attendees];
  }
  isAttending() {
    const calendarOwnerEmail = this.settings.calendarOwnerEmail;
    if (!calendarOwnerEmail) return true;
    return this.attendees.some(
      (attendee) => attendee.params.CN === calendarOwnerEmail && attendee.params.PARTSTAT !== "DECLINED"
    );
  }
  isIgnored() {
    var _a;
    return ((_a = this.settings.ignoredEventTitles) == null ? void 0 : _a.includes(this.summary)) || false;
  }
  isCancelled() {
    return this.event.status === "CANCELLED";
  }
  isActivelyOccurring(now) {
    return now >= this.start && now <= this.end;
  }
  isUpcoming(now) {
    const futureStartLimit = new Date(
      now.getTime() + this.settings.eventFutureHourLimit * MS_PER_HOUR
    );
    return now < this.start && this.start <= futureStartLimit;
  }
  isRecent(now) {
    const pastEndLimit = new Date(
      now.getTime() - this.settings.eventRecentHourLimit * MS_PER_HOUR
    );
    return pastEndLimit <= this.end && this.end < now;
  }
  getLocalStart() {
    return new Date(
      this.start.toLocaleString("en-US", {
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
      })
    );
  }
  generateTitle() {
    const localStart = this.getLocalStart();
    const year = localStart.getFullYear();
    const month = String(localStart.getMonth() + 1).padStart(2, "0");
    const day = String(localStart.getDate()).padStart(2, "0");
    const formattedDate = `${year}-${month}-${day}`;
    return `\u{1F4C6} ${formattedDate}, ${this.normalizeEventTitle(this.summary)}`;
  }
  generateDisplayName() {
    const localStart = this.getLocalStart();
    const formattedDate = localStart.toLocaleDateString("en-US", {
      weekday: "short",
      month: "short",
      day: "numeric"
    });
    const startTime = localStart.toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit",
      hour12: true
    });
    const duration = this.calculateDuration();
    return `${formattedDate} | ${startTime} | ${duration} | ${this.normalizeEventTitle(
      this.summary
    )}`;
  }
  generateAttendeesListMarkdown() {
    let attendeesList = "## Attendees:\n";
    this.attendees.forEach((attendee) => {
      var _a;
      const attendeeName = ((_a = attendee.params) == null ? void 0 : _a.CN) || this.extractEmailFromVal(
        attendee.val || attendee.value || attendee
      );
      attendeesList += `- ${attendeeName}
`;
    });
    return attendeesList;
  }
  calculateDuration() {
    const startMs = this.start.getTime();
    const endMs = this.end.getTime();
    const durationMs = endMs - startMs;
    const hours = Math.floor(durationMs / 36e5);
    const minutes = Math.floor(durationMs % 36e5 / 6e4);
    return `${hours ? `${hours}h` : ""}${minutes ? ` ${minutes}m` : ""}`.trim() || "0m";
  }
  normalizeEventTitle(eventSummary) {
    return eventSummary.replace(/[/:]/g, " ");
  }
  extractEmailFromVal(val) {
    if (!val) return "Unknown";
    const match = val.match(/mailto:(.*)/i) || val.match(/^([^@]+@[^\s]+)$/i);
    return match ? match[1] : val;
  }
};
var CalendarService = class {
  constructor(settings) {
    this.settings = settings;
  }
  async fetchEvents() {
    const icsUrl = this.settings.calendarICSUrl;
    if (!icsUrl || icsUrl.trim() === "")
      throw new Error("No ICS URL provided in settings.");
    let response;
    try {
      const timeoutPromise = new Promise(
        (_, reject) => setTimeout(
          () => reject(new Error("Calendar fetch timed out")),
          FETCH_TIMEOUT_MS
        )
      );
      response = await Promise.race([
        (0, import_obsidian3.request)({ url: icsUrl, method: "GET" }),
        timeoutPromise
      ]);
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to fetch calendar: ${message}`);
    }
    let events;
    try {
      events = ical.sync.parseICS(response);
    } catch (error) {
      throw new Error(
        "Failed to parse calendar data. The ICS file may be malformed."
      );
    }
    return this.processEvents(events);
  }
  findClosestEvent(events, now) {
    const relevantEvents = events.filter(
      (event) => event.isAttending() && !event.isIgnored()
    );
    const currentEvent = relevantEvents.find(
      (event) => event.isActivelyOccurring(now)
    );
    if (currentEvent) return currentEvent;
    const upcomingEvent = relevantEvents.filter((event) => event.isUpcoming(now)).sort((a, b) => a.start.getTime() - b.start.getTime())[0];
    if (upcomingEvent) return upcomingEvent;
    const recentEvent = relevantEvents.filter((event) => event.isRecent(now)).sort((a, b) => b.end.getTime() - a.end.getTime())[0];
    return recentEvent || null;
  }
  getSelectableEvents(events, now) {
    const pastLimit = new Date(
      now.getTime() - this.settings.selectablePastDays * MS_PER_DAY
    );
    const futureLimit = new Date(
      now.getTime() + this.settings.selectableFutureDays * MS_PER_DAY
    );
    return events.filter(
      (event) => event.isAttending() && !event.isIgnored() && event.start >= pastLimit && event.start <= futureLimit
    );
  }
  processEvents(events) {
    const now = /* @__PURE__ */ new Date();
    const minimumProcessingDate = new Date(now);
    minimumProcessingDate.setMonth(minimumProcessingDate.getMonth() - 2);
    const processedEvents = [];
    Object.values(events).forEach((event) => {
      if (event.type !== "VEVENT" || event.recurrenceid) return;
      const vevent = event;
      if (vevent.rrule) {
        const instances = this.expandRecurringEvent(
          vevent,
          minimumProcessingDate,
          now
        );
        processedEvents.push(...instances);
      } else if (vevent.start >= minimumProcessingDate) {
        processedEvents.push(new CalendarEvent(vevent, this.settings));
      }
    });
    return processedEvents.sort(
      (a, b) => a.start.getTime() - b.start.getTime()
    );
  }
  expandRecurringEvent(baseEvent, minimumProcessingDate, now) {
    if (!baseEvent.rrule) return [];
    const occurrences = this.generateOccurrenceDates(
      baseEvent,
      minimumProcessingDate,
      now
    );
    return occurrences.map((date) => this.createOccurrence(baseEvent, date)).filter(
      (event) => event.isAttending() && !event.isIgnored() && !event.isCancelled()
    );
  }
  generateOccurrenceDates(baseEvent, minimumProcessingDate, now) {
    if (!baseEvent.rrule) return [];
    try {
      const rruleSet = new import_rrule.RRuleSet();
      const options = import_rrule.RRule.parseString(baseEvent.rrule.toString());
      options.dtstart = baseEvent.start;
      const mainRule = new import_rrule.RRule(options);
      rruleSet.rrule(mainRule);
      if (baseEvent.exdate) {
        const exdates = Array.isArray(baseEvent.exdate) ? baseEvent.exdate : [baseEvent.exdate];
        exdates.forEach((exdate) => {
          rruleSet.exdate(new Date(exdate));
        });
      }
      const futureLimit = new Date(now.getTime() + 30 * MS_PER_DAY);
      return rruleSet.between(minimumProcessingDate, futureLimit, true);
    } catch (error) {
      console.warn(
        `Invalid recurrence rule for event "${baseEvent.summary}":`,
        error
      );
      return [];
    }
  }
  createOccurrence(baseEvent, date) {
    const dateKey = date.toISOString().split("T")[0];
    const recurrences = baseEvent.recurrences || {};
    const modification = Object.values(recurrences).find((rec) => {
      const recDate = new Date(rec.recurrenceid);
      return recDate.toISOString().split("T")[0] === dateKey;
    });
    if (modification) {
      return new CalendarEvent(modification, this.settings);
    }
    const eventDuration = baseEvent.end.getTime() - baseEvent.start.getTime();
    const newStart = new Date(date.getTime());
    const newEnd = new Date(date.getTime() + eventDuration);
    const occurrenceEvent = {
      ...baseEvent,
      start: newStart,
      end: newEnd
    };
    return new CalendarEvent(occurrenceEvent, this.settings);
  }
};

// src/main.ts
var CalendarEventSyncPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.calendarService = new CalendarService(this.settings);
    this.addCommand({
      id: "sync-with-closest-event",
      name: "Sync with closest event",
      callback: () => this.updateNoteFromCalendarEvent()
    });
    this.addCommand({
      id: "sync-with-selected-event",
      name: "Select event to sync",
      callback: () => this.listCalendarEvents()
    });
    this.addSettingTab(new SettingTab(this.app, this));
  }
  async updateNoteFromCalendarEvent() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian4.Notice("No active note found. Please open a note first.", 5e3);
      return;
    }
    try {
      const events = await this.calendarService.fetchEvents();
      const relevantEvent = this.calendarService.findClosestEvent(
        events,
        /* @__PURE__ */ new Date()
      );
      if (relevantEvent) {
        await this.syncNoteWithEvent(activeFile, relevantEvent);
        new import_obsidian4.Notice("Event synced with note.", 5e3);
      } else {
        new import_obsidian4.Notice("No relevant events found to sync with.", 5e3);
      }
    } catch (error) {
      this.handleError(error);
    }
  }
  async listCalendarEvents() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian4.Notice("No active note found. Please open a note first.", 5e3);
      return;
    }
    try {
      const events = await this.calendarService.fetchEvents();
      const selectableEvents = this.calendarService.getSelectableEvents(
        events,
        /* @__PURE__ */ new Date()
      );
      if (selectableEvents.length === 0) {
        new import_obsidian4.Notice(
          "No events found for the specified time range.",
          5e3
        );
        return;
      }
      new EventChoiceModal(
        this.app,
        selectableEvents,
        (selectedEvent) => this.syncNoteWithEvent(activeFile, selectedEvent)
      ).open();
    } catch (error) {
      this.handleError(error);
    }
  }
  async syncNoteWithEvent(file, event) {
    const attendeesRegex = /## Attendees:\n(?:- [^\n]*\n)*/;
    const attendeesList = event.generateAttendeesListMarkdown();
    await this.app.vault.process(file, (content) => {
      if (content.match(attendeesRegex)) {
        return content.replace(attendeesRegex, attendeesList);
      }
      return `${attendeesList}
${content}`;
    });
    const newPath = file.path.replace(
      /[^/]+$/,
      `${event.generateTitle()}.md`
    );
    await this.app.vault.rename(file, newPath);
  }
  handleError(error) {
    var _a;
    console.error("Calendar Event Sync Error:", error);
    const message = ((_a = error.message) == null ? void 0 : _a.includes("404")) ? "Couldn't sync with calendar events. Make sure your ICS URL is correct in the plugin settings." : `Couldn't sync with calendar event: ${error.message}`;
    new import_obsidian4.Notice(message, 0);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.calendarService = new CalendarService(this.settings);
  }
};
